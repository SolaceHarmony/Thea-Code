diff --cc src/extension.ts
index c24286080,f02f769a9..000000000
--- a/src/extension.ts
+++ b/src/extension.ts
@@@ -1,33 -1,11 +1,8 @@@
  import * as vscode from "vscode"
- import * as dotenvx from "@dotenvx/dotenvx"
- import * as path from "path"
- 
- // Load environment variables from .env file
- try {
- 	// Specify path to .env file in the project root directory
- 	const envPath = path.join(__dirname, "..", ".env")
- 	dotenvx.config({ path: envPath })
- } catch (e) {
- 	// Silently handle environment loading errors
- 	console.warn("Failed to load environment variables:", e)
- }
- 
- import "./utils/path" // Necessary to have access to String.prototype.toPosix.
  
- import { initializeI18n } from "./i18n"
- import { TheaProvider } from "./core/webview/TheaProvider" // Renamed import
- import { CodeActionProvider } from "./core/CodeActionProvider"
- import { DIFF_VIEW_URI_SCHEME } from "./integrations/editor/DiffViewProvider" // Fixed: removed type-only import
- import { McpServerManager } from "./services/mcp/management/McpServerManager"
- import { telemetryService } from "./services/telemetry/TelemetryService"
- import { TerminalRegistry } from "./integrations/terminal/TerminalRegistry"
- import { API } from "./exports/api"
- import { migrateSettings } from "./utils/migrateSettings"
- 
- import { handleUri, registerCommands, registerCodeActions, registerTerminalActions } from "./activate"
- import { formatLanguage } from "./shared/language"
- import { EXTENSION_DISPLAY_NAME, EXTENSION_NAME, configSection } from "./shared/config/thea-config"
+ // Lightweight imports only - heavy modules will be loaded dynamically
+ import { EXTENSION_DISPLAY_NAME, EXTENSION_NAME } from "./shared/config/thea-config"
  
 -// Type-only imports (don't affect runtime)
 -import type { TheaProvider as TheaProviderType } from "./core/webview/TheaProvider"
 -
  /**
   * Built using https://github.com/microsoft/vscode-webview-ui-toolkit
   *
@@@ -38,131 -16,201 +13,178 @@@
  
  let outputChannel: vscode.OutputChannel
  let extensionContext: vscode.ExtensionContext
- let provider: TheaProvider | undefined // <-- single shared provider variable
 -let provider: TheaProviderType | undefined // <-- single shared provider variable
  
  // This method is called when your extension is activated.
  // Your extension is activated the very first time the command is executed.
  export async function activate(context: vscode.ExtensionContext) {
 -	console.log('[Thea Code] activate() function called')
 -	
 -	// Detect e2e/test mode to reduce heavy startup during integration tests
 -	const isE2E = process.env.THEA_E2E === '1' || process.env.NODE_ENV === 'test'
 -	console.log(`[Thea Code] Test mode: ${isE2E}`)
 -	
--	extensionContext = context
--	outputChannel = vscode.window.createOutputChannel(String(EXTENSION_DISPLAY_NAME))
--	context.subscriptions.push(outputChannel)
--	outputChannel.appendLine(`${EXTENSION_DISPLAY_NAME} extension activated`)
--
- 	// Detect e2e/test mode to reduce heavy startup during integration tests
- 	const isE2E = process.env.THEA_E2E === "1" || process.env.NODE_ENV === "test"
--	outputChannel.appendLine(`Activation starting (testMode=${isE2E})`)
--
--	if (isE2E) {
--		outputChannel.appendLine("E2E mode detected: Performing lightweight activation")
--
- 		// Create a minimal provider and register it so commands can interact with it
- 		provider = new TheaProvider(context, outputChannel, "sidebar")
- 		context.subscriptions.push(
- 			vscode.window.registerWebviewViewProvider(String(TheaProvider.sideBarId), provider, {
- 				webviewOptions: { retainContextWhenHidden: true },
- 			}),
- 		)
 -		// Register minimal commands for tests without creating a provider
 -		const testCommands = [
 -			`${EXTENSION_NAME}.plusButtonClicked`,
 -			`${EXTENSION_NAME}.mcpButtonClicked`,
 -			`${EXTENSION_NAME}.historyButtonClicked`,
 -			`${EXTENSION_NAME}.popoutButtonClicked`,
 -			`${EXTENSION_NAME}.settingsButtonClicked`,
 -			`${EXTENSION_NAME}.openInNewTab`,
 -			`${EXTENSION_NAME}.explainCode`,
 -			`${EXTENSION_NAME}.fixCode`,
 -			`${EXTENSION_NAME}.improveCode`,
 -		]
--
- 		// Register the commands expected by the tests
- 		registerCommands({ context, outputChannel, provider: provider! })
 -		// Register stub commands for testing
 -		for (const command of testCommands) {
 -			context.subscriptions.push(
 -				vscode.commands.registerCommand(command, () => {
 -					outputChannel.appendLine(`Test stub command executed: ${command}`)
 -				})
 -			)
 -		}
--
- 		// Return the API so the e2e setup can obtain it via extension.exports
- 		return new API(outputChannel, provider!)
 -		// Return a minimal API for tests
 -		const minimalApi = {
 -			outputChannel,
 -			isTestMode: true,
 -			version: context.extension.packageJSON.version
 -		}
 -		
 -		return minimalApi
--	}
--
- 	// Non-E2E activation continues here; perform full initialization safely
 -	// Non-E2E activation continues here with lazy loading
 -	outputChannel.appendLine("Starting lazy initialization...")
 -	
 -	// Load heavy modules dynamically
--	try {
- 		// Migrate old settings to new
- 		await migrateSettings(context, outputChannel)
- 	} catch (err) {
- 		outputChannel.appendLine(`migrateSettings failed in non-E2E activation: ${String(err)}`)
- 	}
- 
- 	// Initialize telemetry service after environment variables are loaded.
- 	telemetryService.initialize()
- 
- 	// Initialize i18n for internationalization support
- 	await initializeI18n(context.globalState.get("language") ?? formatLanguage(vscode.env.language))
- 
- 	// Initialize terminal shell execution handlers.
- 	TerminalRegistry.initialize()
- 
- 	// Get default commands from configuration.
- 	const defaultCommands =
- 		vscode.workspace.getConfiguration((configSection as () => string)()).get<string[]>("allowedCommands") || []
- 
- 	// Initialize global state if not already set.
- 	if (!context.globalState.get("allowedCommands")) {
- 		context.globalState.update("allowedCommands", defaultCommands)
- 	}
- 
- 	outputChannel.appendLine("Creating TheaProvider...")
- 	provider = new TheaProvider(context, outputChannel, "sidebar") // assign to shared variable
- 	outputChannel.appendLine("TheaProvider created")
- 	if (!isE2E) {
 -		// Load environment variables if needed
 -		try {
 -			const dotenvx = await import("@dotenvx/dotenvx")
 -			const path = await import("path")
 -			const envPath = path.join(__dirname, "..", ".env")
 -			dotenvx.config({ path: envPath })
 -		} catch (e) {
 -			// Silently handle environment loading errors
 -			outputChannel.appendLine(`Failed to load .env file: ${e}`)
 -		}
 -		
 -		// Load path utilities first
 -		await import("./utils/path")
 -		
 -		// Load configuration
 -		const { configSection } = await import("./shared/config/thea-config")
 -		
 -		// Migration and settings
 -		const { migrateSettings } = await import("./utils/migrateSettings")
 -		try {
 -			await migrateSettings(context, outputChannel)
 -		} catch (err) {
 -			outputChannel.appendLine(`migrateSettings failed: ${String(err)}`)
 -		}
 -		
 -		// Initialize telemetry
 -		const { telemetryService } = await import("./services/telemetry/TelemetryService")
 -		telemetryService.initialize()
 -		
 -		// Initialize i18n
 -		const { initializeI18n } = await import("./i18n")
 -		const { formatLanguage } = await import("./shared/language")
 -		await initializeI18n(context.globalState.get("language") ?? formatLanguage(vscode.env.language))
 -		
 -		// Initialize terminal
 -		const { TerminalRegistry } = await import("./integrations/terminal/TerminalRegistry")
 -		TerminalRegistry.initialize()
 -		
 -		// Get default commands from configuration
 -		const defaultCommands =
 -			vscode.workspace.getConfiguration((configSection as () => string)()).get<string[]>("allowedCommands") || []
 -		
 -		// Initialize global state if not already set
 -		if (!context.globalState.get("allowedCommands")) {
 -			context.globalState.update("allowedCommands", defaultCommands)
 -		}
 -		
 -		outputChannel.appendLine("Creating TheaProvider...")
 -		const { TheaProvider } = await import("./core/webview/TheaProvider")
 -		provider = new TheaProvider(context, outputChannel, "sidebar") as TheaProviderType
 -		outputChannel.appendLine("TheaProvider created")
--		telemetryService.setProvider(provider!)
- 	}
--
--	context.subscriptions.push(
--		vscode.window.registerWebviewViewProvider(String(TheaProvider.sideBarId), provider!, {
--			webviewOptions: { retainContextWhenHidden: true },
--		}),
--	)
--
- 	registerCommands({ context, outputChannel, provider: provider! })
 -		const { registerCommands } = await import("./activate")
 -		registerCommands({ context, outputChannel, provider: provider! })
--
--	/**
--	 * We use the text document content provider API to show the left side for diff
--	 * view by creating a virtual document for the original content. This makes it
--	 * readonly so users know to edit the right side if they want to keep their changes.
--	 *
--	 * This API allows you to create readonly documents in VSCode from arbitrary
--	 * sources, and works by claiming an uri-scheme for which your provider then
--	 * returns text contents. The scheme must be provided when registering a
--	 * provider and cannot change afterwards.
--	 *
--	 * Note how the provider doesn't create uris for virtual documents - its role
--	 * is to provide contents given such an uri. In return, content providers are
--	 * wired into the open document logic so that providers are always considered.
--	 *
--	 * https://code.visualstudio.com/api/extension-guides/virtual-documents
--	 */
- 	const diffContentProvider = new (class implements vscode.TextDocumentContentProvider {
- 		provideTextDocumentContent(uri: vscode.Uri): string {
- 			return Buffer.from(uri.query, "base64").toString("utf-8")
- 		}
- 	})()
- 
- 	context.subscriptions.push(
- 		vscode.workspace.registerTextDocumentContentProvider(DIFF_VIEW_URI_SCHEME, diffContentProvider),
- 	)
- 
- 	context.subscriptions.push(vscode.window.registerUriHandler({ handleUri }))
- 
- 	// Register code actions provider.
- 	context.subscriptions.push(
- 		vscode.languages.registerCodeActionsProvider({ pattern: "**/*" }, new CodeActionProvider(), {
- 			providedCodeActionKinds: CodeActionProvider.providedCodeActionKinds,
- 		}),
- 	)
- 
- 	registerCodeActions(context)
- 	registerTerminalActions(context)
 -		// Register diff view provider
 -		const { DIFF_VIEW_URI_SCHEME } = await import("./integrations/editor/DiffViewProvider")
 -		const diffContentProvider = new (class implements vscode.TextDocumentContentProvider {
 -			provideTextDocumentContent(uri: vscode.Uri): string {
 -				return Buffer.from(uri.query, "base64").toString("utf-8")
 -			}
 -		})()
 -		
 -		context.subscriptions.push(
 -			vscode.workspace.registerTextDocumentContentProvider(DIFF_VIEW_URI_SCHEME, diffContentProvider),
 -		)
 -		
 -		const { handleUri } = await import("./activate")
 -		context.subscriptions.push(vscode.window.registerUriHandler({ handleUri }))
--
- 	// Allows other extensions to activate once Thea is ready.
- 	vscode.commands.executeCommand(`${EXTENSION_NAME}.activationCompleted`)
 -		// Register code actions provider
 -		const { CodeActionProvider } = await import("./core/CodeActionProvider")
 -		context.subscriptions.push(
 -			vscode.languages.registerCodeActionsProvider({ pattern: "**/*" }, new CodeActionProvider(), {
 -				providedCodeActionKinds: CodeActionProvider.providedCodeActionKinds,
 -			}),
 -		)
 -		
 -		const { registerCodeActions, registerTerminalActions } = await import("./activate")
 -		registerCodeActions(context)
 -		registerTerminalActions(context)
--
- 	// Implements the `TheaCodeAPI` interface.
- 	return new API(outputChannel, provider!)
 -		// Allows other extensions to activate once Thea is ready
 -		vscode.commands.executeCommand(`${EXTENSION_NAME}.activationCompleted`)
 -		
 -		// Return the API
 -		const { API } = await import("./exports/api")
 -		return new API(outputChannel, provider!)
 -	} catch (error) {
 -		outputChannel.appendLine(`Failed to initialize extension: ${error}`)
 -		console.error('[Thea Code] Failed to initialize:', error)
 -		throw error
 -	}
++  console.log('[Thea Code] activate() function called')
++
++  // Detect e2e/test mode to reduce heavy startup during integration tests
++  const isE2E = process.env.THEA_E2E === '1' || process.env.NODE_ENV === 'test'
++  console.log(`[Thea Code] Test mode: ${isE2E}`)
++
++  extensionContext = context
++  outputChannel = vscode.window.createOutputChannel(String(EXTENSION_DISPLAY_NAME))
++  context.subscriptions.push(outputChannel)
++  outputChannel.appendLine(`${EXTENSION_DISPLAY_NAME} extension activated`)
++  outputChannel.appendLine(`Activation starting (testMode=${isE2E})`)
++
++  if (isE2E) {
++    outputChannel.appendLine("E2E mode detected: Performing lightweight activation")
++
++    // Register minimal commands for tests without creating a provider
++    const testCommands = [
++      `${EXTENSION_NAME}.plusButtonClicked`,
++      `${EXTENSION_NAME}.mcpButtonClicked`,
++      `${EXTENSION_NAME}.historyButtonClicked`,
++      `${EXTENSION_NAME}.popoutButtonClicked`,
++      `${EXTENSION_NAME}.settingsButtonClicked`,
++      `${EXTENSION_NAME}.openInNewTab`,
++      `${EXTENSION_NAME}.explainCode`,
++      `${EXTENSION_NAME}.fixCode`,
++      `${EXTENSION_NAME}.improveCode`,
++    ]
++
++    for (const command of testCommands) {
++      context.subscriptions.push(
++        vscode.commands.registerCommand(command, () => {
++          outputChannel.appendLine(`Test stub command executed: ${command}`)
++        }),
++      )
++    }
++
++    // Return a minimal API for tests
++    const minimalApi = {
++      outputChannel,
++      isTestMode: true,
++      version: context.extension.packageJSON.version,
++    }
++    return minimalApi
++  }
++
++  // Non-E2E activation continues here with lazy loading
++  outputChannel.appendLine("Starting lazy initialization...")
++
++  try {
++    // Load environment variables if needed
++    try {
++      const dotenvx = await import("@dotenvx/dotenvx")
++      const path = await import("path")
++      const envPath = path.join(__dirname, "..", ".env")
++      dotenvx.config({ path: envPath })
++    } catch (e) {
++      outputChannel.appendLine(`Failed to load .env file: ${e}`)
++    }
++
++    // Load path utilities first
++    await import("./utils/path")
++
++    // Load configuration
++    const { configSection } = await import("./shared/config/thea-config")
++
++    // Migration and settings
++    const { migrateSettings } = await import("./utils/migrateSettings")
++    try {
++      await migrateSettings(context, outputChannel)
++    } catch (err) {
++      outputChannel.appendLine(`migrateSettings failed: ${String(err)}`)
++    }
++
++    // Initialize telemetry
++    const { telemetryService } = await import("./services/telemetry/TelemetryService")
++    telemetryService.initialize()
++
++    // Initialize i18n
++    const { initializeI18n } = await import("./i18n")
++    const { formatLanguage } = await import("./shared/language")
++    await initializeI18n(context.globalState.get("language") ?? formatLanguage(vscode.env.language))
++
++    // Initialize terminal
++    const { TerminalRegistry } = await import("./integrations/terminal/TerminalRegistry")
++    TerminalRegistry.initialize()
++
++    // Get default commands from configuration
++    const defaultCommands =
++      vscode.workspace.getConfiguration((configSection as () => string)()).get<string[]>("allowedCommands") || []
++
++    if (!context.globalState.get("allowedCommands")) {
++      context.globalState.update("allowedCommands", defaultCommands)
++    }
++
++    outputChannel.appendLine("Creating TheaProvider...")
++    const { TheaProvider } = await import("./core/webview/TheaProvider")
++    const theaProvider = new TheaProvider(context, outputChannel, "sidebar")
++    outputChannel.appendLine("TheaProvider created")
++    telemetryService.setProvider(theaProvider)
++
++    context.subscriptions.push(
++      vscode.window.registerWebviewViewProvider(String(TheaProvider.sideBarId), theaProvider, {
++        webviewOptions: { retainContextWhenHidden: true },
++      }),
++    )
++
++    const { registerCommands } = await import("./activate")
++    registerCommands({ context, outputChannel, provider: theaProvider })
++
++    // Register diff view provider
++    const { DIFF_VIEW_URI_SCHEME } = await import("./integrations/editor/DiffViewProvider")
++    const diffContentProvider = new (class implements vscode.TextDocumentContentProvider {
++      provideTextDocumentContent(uri: vscode.Uri): string {
++        return Buffer.from(uri.query, "base64").toString("utf-8")
++      }
++    })()
++
++    context.subscriptions.push(
++      vscode.workspace.registerTextDocumentContentProvider(DIFF_VIEW_URI_SCHEME, diffContentProvider),
++    )
++
++    const { handleUri } = await import("./activate")
++    context.subscriptions.push(vscode.window.registerUriHandler({ handleUri }))
++
++    // Register code actions provider
++    const { CodeActionProvider } = await import("./core/CodeActionProvider")
++    context.subscriptions.push(
++      vscode.languages.registerCodeActionsProvider({ pattern: "**/*" }, new CodeActionProvider(), {
++        providedCodeActionKinds: CodeActionProvider.providedCodeActionKinds,
++      }),
++    )
++
++    const { registerCodeActions, registerTerminalActions } = await import("./activate")
++    registerCodeActions(context)
++    registerTerminalActions(context)
++
++    // Allows other extensions to activate once Thea is ready
++    vscode.commands.executeCommand(`${EXTENSION_NAME}.activationCompleted`)
++
++    // Return the API
++    const { API } = await import("./exports/api")
++    return new API(outputChannel, theaProvider)
++  } catch (error) {
++    outputChannel.appendLine(`Failed to initialize extension: ${error}`)
++    console.error('[Thea Code] Failed to initialize:', error)
++    throw error
++  }
  }
  
  // This method is called when your extension is deactivated
  export async function deactivate() {
- 	outputChannel.appendLine(`${EXTENSION_DISPLAY_NAME} extension deactivated`)
- 	// Clean up MCP server manager
- 	await McpServerManager.cleanup(extensionContext)
- 	await telemetryService.shutdown()
- 
- 	// Clean up terminal handlers
- 	TerminalRegistry.cleanup()
 -	if (outputChannel) {
 -		outputChannel.appendLine(`${EXTENSION_DISPLAY_NAME} extension deactivated`)
 -	}
 -	
 -	// Only cleanup if modules were loaded
 -	try {
 -		const { McpServerManager } = await import("./services/mcp/management/McpServerManager")
 -		await McpServerManager.cleanup(extensionContext)
 -	} catch {}
 -	
 -	try {
 -		const { telemetryService } = await import("./services/telemetry/TelemetryService")
 -		await telemetryService.shutdown()
 -	} catch {}
 -	
 -	try {
 -		const { TerminalRegistry } = await import("./integrations/terminal/TerminalRegistry")
 -		TerminalRegistry.cleanup()
 -	} catch {}
++  if (outputChannel) {
++    outputChannel.appendLine(`${EXTENSION_DISPLAY_NAME} extension deactivated`)
++  }
++
++  // Only cleanup if modules were loaded
++  try {
++    const { McpServerManager } = await import("./services/mcp/management/McpServerManager")
++    await McpServerManager.cleanup(extensionContext)
++  } catch {}
++
++  try {
++    const { telemetryService } = await import("./services/telemetry/TelemetryService")
++    await telemetryService.shutdown()
++  } catch {}
++
++  try {
++    const { TerminalRegistry } = await import("./integrations/terminal/TerminalRegistry")
++    TerminalRegistry.cleanup()
++  } catch {}
  }
