{
  "timestamp": "2025-08-21T02:33:36.695Z",
  "summary": {
    "totalFiles": 181,
    "filesWithIssues": 129,
    "filesFixable": 89
  },
  "issueTypes": {
    "malformedImportAfterBrace": {
      "files": [
        "e2e/src/suite/migrateSettings.test.ts",
        "e2e/src/suite/utils/xml-matcher.test.ts",
        "e2e/src/suite/utils/model-pattern-detection.test.ts",
        "e2e/src/suite/utils/model-capabilities.test.ts",
        "e2e/src/suite/utils/json-xml-bridge.test.ts",
        "e2e/src/suite/utils/json-xml-bridge-jsonmatcher.test.ts",
        "e2e/src/suite/utils/cost.test.ts",
        "e2e/src/suite/utils/logging/CompactTransport.test.ts",
        "e2e/src/suite/shared/vsCodeSelectorUtils.test.ts",
        "e2e/src/suite/shared/support-prompts.test.ts",
        "e2e/src/suite/shared/language.test.ts",
        "e2e/src/suite/shared/formatPath.test.ts",
        "e2e/src/suite/shared/experiments.test.ts",
        "e2e/src/suite/shared/doesFileMatchRegex.test.ts",
        "e2e/src/suite/shared/context-mentions.test.ts",
        "e2e/src/suite/shared/checkExistApiConfig.test.ts",
        "e2e/src/suite/services/checkpoints-excludes.test.ts",
        "e2e/src/suite/services/tree-sitter/index.test.ts",
        "e2e/src/suite/services/mcp/ollama-mcp-integration.test.ts",
        "e2e/src/suite/services/mcp/UnifiedMcpToolSystem.test.ts",
        "e2e/src/suite/services/mcp/SseTransport.test.ts",
        "e2e/src/suite/services/mcp/McpToolRegistry.test.ts",
        "e2e/src/suite/services/mcp/McpIntegration.test.ts",
        "e2e/src/suite/services/mcp/McpHub.test.ts",
        "e2e/src/suite/services/mcp/McpConverters.test.ts",
        "e2e/src/suite/services/mcp/core/McpToolRouter.test.ts",
        "e2e/src/suite/schemas/index.test.ts",
        "e2e/src/suite/integrations/terminal/TerminalRegistry.test.ts",
        "e2e/src/suite/integrations/terminal/TerminalProcessInterpretExitCode.test.ts",
        "e2e/src/suite/integrations/terminal/TerminalProcessExec.test.ts",
        "e2e/src/suite/integrations/terminal/TerminalProcess.test.ts",
        "e2e/src/suite/integrations/misc/read-lines.test.ts",
        "e2e/src/suite/integrations/misc/line-counter.test.ts",
        "e2e/src/suite/integrations/misc/extract-text.test.ts",
        "e2e/src/suite/integrations/editor/detect-omission.test.ts",
        "e2e/src/suite/integrations/editor/DiffViewProvider.test.ts",
        "e2e/src/suite/core/read-file-tool.test.ts",
        "e2e/src/suite/core/read-file-maxReadFileLine.test.ts",
        "e2e/src/suite/core/parse-assistant-message.test.ts",
        "e2e/src/suite/core/mode-validator.test.ts",
        "e2e/src/suite/core/access-mcp-resource-tool.test.ts",
        "e2e/src/suite/core/EditorUtils.test.ts",
        "e2e/src/suite/core/CodeActionProvider2.test.ts",
        "e2e/src/suite/core/CodeActionProvider.test.ts",
        "e2e/src/suite/core/webview/getNonce.test.ts",
        "e2e/src/suite/core/webview/TheaMcpManager.test.ts",
        "e2e/src/suite/core/webview/TheaCacheManager.test.ts",
        "e2e/src/suite/core/webview/history/TheaTaskHistory.io-cleanup.test.ts",
        "e2e/src/suite/core/prompts/sections.test.ts",
        "e2e/src/suite/core/prompts/responses-theaignore.test.ts",
        "e2e/src/suite/core/prompts/custom-system-prompt.test.ts",
        "e2e/src/suite/core/prompts/sections/custom-instructions.test.ts",
        "e2e/src/suite/core/mentions/index.test.ts",
        "e2e/src/suite/core/ignore/TheaIgnoreController.test.ts",
        "e2e/src/suite/core/ignore/TheaIgnoreController.security.test.ts",
        "e2e/src/suite/core/diff/strategies/unified.test.ts",
        "e2e/src/suite/core/diff/strategies/new-unified.test.ts",
        "e2e/src/suite/core/diff/strategies/multi-search-replace.test.ts",
        "e2e/src/suite/core/diff/strategies/new-unified/search-strategies.test.ts",
        "e2e/src/suite/core/diff/strategies/new-unified/edit-strategies.test.ts",
        "e2e/src/suite/api/transform/stream.test.ts",
        "e2e/src/suite/api/transform/r1-format.test.ts",
        "e2e/src/suite/api/transform/neutral-ollama-format.test.ts",
        "e2e/src/suite/api/providers/vscode-lm.test.ts",
        "e2e/src/suite/api/providers/vertex.test.ts",
        "e2e/src/suite/api/providers/unbound.test.ts",
        "e2e/src/suite/api/providers/openai-native.test.ts",
        "e2e/src/suite/api/providers/shared/tool-use.test.ts"
      ],
      "totalCount": 69,
      "description": "Import statement inside another import"
    },
    "expectSyntax": {
      "files": [
        "e2e/src/suite/migrateSettings.test.ts",
        "e2e/src/suite/utils/model-pattern-detection.test.ts",
        "e2e/src/suite/utils/model-capabilities.test.ts",
        "e2e/src/suite/utils/json-xml-bridge.test.ts",
        "e2e/src/suite/utils/json-xml-bridge.edge-cases.test.ts",
        "e2e/src/suite/utils/logging/CompactTransport.test.ts",
        "e2e/src/suite/test/dynamic-providers-mock.test.ts",
        "e2e/src/suite/test/generic-provider-mock/all-providers-runtime.test.ts",
        "e2e/src/suite/shared/support-prompts.test.ts",
        "e2e/src/suite/shared/modes.test.ts",
        "e2e/src/suite/shared/language.test.ts",
        "e2e/src/suite/shared/formatPath.test.ts",
        "e2e/src/suite/shared/experiments.test.ts",
        "e2e/src/suite/shared/doesFileMatchRegex.test.ts",
        "e2e/src/suite/shared/context-mentions.test.ts",
        "e2e/src/suite/shared/checkExistApiConfig.test.ts",
        "e2e/src/suite/services/tree-sitter/languageParser.test.ts",
        "e2e/src/suite/services/tree-sitter/index.test.ts",
        "e2e/src/suite/services/mcp/ollama-mcp-integration.test.ts",
        "e2e/src/suite/services/mcp/UnifiedMcpToolSystem.test.ts",
        "e2e/src/suite/services/mcp/SseTransport.test.ts",
        "e2e/src/suite/services/mcp/McpToolRegistry.test.ts",
        "e2e/src/suite/services/mcp/McpHub.test.ts",
        "e2e/src/suite/services/mcp/transport/StdioTransport.lifecycle.test.ts",
        "e2e/src/suite/services/mcp/transport/StdioTransport.fallback.test.ts",
        "e2e/src/suite/services/mcp/transport/SseTransport.lifecycle.test.ts",
        "e2e/src/suite/services/mcp/providers/MockMcpProvider.test.ts",
        "e2e/src/suite/services/mcp/providers/EmbeddedMcpProvider.lifecycle.test.ts",
        "e2e/src/suite/services/mcp/performance/PerformanceValidation.test.ts",
        "e2e/src/suite/services/mcp/integration/ProviderTransportIntegration.test.ts",
        "e2e/src/suite/services/mcp/formats/OpenAIFunctionFormat.test.ts",
        "e2e/src/suite/services/mcp/e2e/ToolUseFlows.test.ts",
        "e2e/src/suite/services/mcp/core/McpToolRouter.test.ts",
        "e2e/src/suite/services/mcp/core/McpToolRouter.round-trip.test.ts",
        "e2e/src/suite/services/mcp/core/McpToolRouter.lifecycle.test.ts",
        "e2e/src/suite/services/mcp/core/McpToolExecutor.test.ts",
        "e2e/src/suite/services/mcp/core/McpConverters.xml-escaping.test.ts",
        "e2e/src/suite/services/mcp/core/McpConverters.test.ts",
        "e2e/src/suite/services/mcp/core/McpConverters.edge-cases.test.ts",
        "e2e/src/suite/services/mcp/client/SseClientFactory.test.ts",
        "e2e/src/suite/services/mcp/__tests__/performance/PerformanceValidation.test.ts",
        "e2e/src/suite/services/mcp/__tests__/formats/OpenAIFunctionFormat.test.ts",
        "e2e/src/suite/services/checkpoints/excludes.test.ts",
        "e2e/src/suite/services/checkpoints/ShadowCheckpointService.test.ts",
        "e2e/src/suite/schemas/index.test.ts",
        "e2e/src/suite/integrations/workspace/WorkspaceTracker.test.ts",
        "e2e/src/suite/integrations/misc/read-lines.test.ts",
        "e2e/src/suite/integrations/misc/line-counter.test.ts",
        "e2e/src/suite/integrations/misc/extract-text.test.ts",
        "e2e/src/suite/integrations/editor/detect-omission.test.ts",
        "e2e/src/suite/core/read-file-tool.test.ts",
        "e2e/src/suite/core/mode-validator.test.ts",
        "e2e/src/suite/core/EditorUtils.test.ts",
        "e2e/src/suite/core/CodeActionProvider2.test.ts",
        "e2e/src/suite/core/CodeActionProvider.test.ts",
        "e2e/src/suite/core/webview/getNonce.test.ts",
        "e2e/src/suite/core/webview/TheaTaskStack.test.ts",
        "e2e/src/suite/core/webview/TheaMcpManager.test.ts",
        "e2e/src/suite/core/webview/history/TheaTaskHistory.io-cleanup.test.ts",
        "e2e/src/suite/core/tools/attemptCompletionTool.flow.test.ts",
        "e2e/src/suite/core/sliding-window/sliding-window.test.ts",
        "e2e/src/suite/core/prompts/system.test.ts",
        "e2e/src/suite/core/prompts/sections.test.ts",
        "e2e/src/suite/core/prompts/responses-theaignore.test.ts",
        "e2e/src/suite/core/prompts/custom-system-prompt.test.ts",
        "e2e/src/suite/core/prompts/sections/custom-instructions.test.ts",
        "e2e/src/suite/core/ignore/TheaIgnoreController.test.ts",
        "e2e/src/suite/core/ignore/TheaIgnoreController.security.test.ts",
        "e2e/src/suite/core/diff/strategies/multi-search-replace.test.ts",
        "e2e/src/suite/core/diff/strategies/new-unified/edit-strategies.test.ts",
        "e2e/src/suite/core/config/ProviderSettingsManager.test.ts",
        "e2e/src/suite/core/config/ModeConfig.test.ts",
        "e2e/src/suite/core/config/CustomModesSettings.test.ts",
        "e2e/src/suite/core/config/CustomModesManager.test.ts",
        "e2e/src/suite/core/config/ContextProxy.test.ts",
        "e2e/src/suite/api/transform/vscode-lm-format.test.ts",
        "e2e/src/suite/api/transform/vertex-gemini-format.test.ts",
        "e2e/src/suite/api/transform/stream.test.ts",
        "e2e/src/suite/api/transform/simple-format.test.ts",
        "e2e/src/suite/api/transform/r1-format.test.ts",
        "e2e/src/suite/api/transform/openrouter.test.ts",
        "e2e/src/suite/api/transform/neutral-openai-format.test.ts",
        "e2e/src/suite/api/transform/neutral-ollama-format.test.ts",
        "e2e/src/suite/api/transform/mistral-format.test.ts",
        "e2e/src/suite/api/providers/vscode-lm.test.ts",
        "e2e/src/suite/api/providers/vertex.edge-cases.test.ts",
        "e2e/src/suite/api/providers/unbound.test.ts",
        "e2e/src/suite/api/providers/requesty.test.ts",
        "e2e/src/suite/api/providers/openai.test.ts",
        "e2e/src/suite/api/providers/openai.edge-cases.test.ts",
        "e2e/src/suite/api/providers/openai-native.test.ts",
        "e2e/src/suite/api/providers/model-registry.test.ts",
        "e2e/src/suite/api/providers/bedrock.edge-cases.test.ts",
        "e2e/src/suite/api/providers/base-provider.schema-only.test.ts",
        "e2e/src/suite/api/providers/all-dynamic-providers.runtime.test.ts",
        "e2e/src/suite/api/providers/shared/tool-use.test.ts"
      ],
      "totalCount": 964,
      "description": "Jest expect calls that need conversion to assert"
    },
    "importsAfterCode": {
      "files": [
        "e2e/src/suite/NeutralVertexClient.test.ts",
        "e2e/src/suite/utils/port-utils.retry-timeout.test.ts",
        "e2e/src/suite/utils/model-pattern-detection.test.ts",
        "e2e/src/suite/utils/model-capabilities.test.ts",
        "e2e/src/suite/utils/json-xml-bridge.edge-cases.test.ts",
        "e2e/src/suite/utils/logging/CompactTransport.test.ts",
        "e2e/src/suite/shared/modes.test.ts",
        "e2e/src/suite/services/checkpoints-excludes.test.ts",
        "e2e/src/suite/services/tree-sitter/languageParser.test.ts",
        "e2e/src/suite/services/tree-sitter/index.test.ts",
        "e2e/src/suite/services/mcp/transport/StdioTransport.lifecycle.test.ts",
        "e2e/src/suite/services/mcp/transport/StdioTransport.fallback.test.ts",
        "e2e/src/suite/services/mcp/transport/SseTransport.lifecycle.test.ts",
        "e2e/src/suite/services/mcp/providers/EmbeddedMcpProvider.lifecycle.test.ts",
        "e2e/src/suite/services/mcp/performance/PerformanceValidation.test.ts",
        "e2e/src/suite/services/mcp/integration/ProviderTransportIntegration.test.ts",
        "e2e/src/suite/services/mcp/formats/OpenAIFunctionFormat.test.ts",
        "e2e/src/suite/services/mcp/e2e/ToolUseFlows.test.ts",
        "e2e/src/suite/services/mcp/core/McpToolRouter.test.ts",
        "e2e/src/suite/services/mcp/core/McpToolRouter.round-trip.test.ts",
        "e2e/src/suite/services/mcp/core/McpToolRouter.lifecycle.test.ts",
        "e2e/src/suite/services/mcp/core/McpConverters.xml-escaping.test.ts",
        "e2e/src/suite/services/mcp/core/McpConverters.edge-cases.test.ts",
        "e2e/src/suite/services/mcp/client/SseClientFactory.test.ts",
        "e2e/src/suite/services/mcp/__tests__/performance/PerformanceValidation.test.ts",
        "e2e/src/suite/services/mcp/__tests__/formats/OpenAIFunctionFormat.test.ts",
        "e2e/src/suite/integrations/terminal/TerminalRegistry.test.ts",
        "e2e/src/suite/integrations/terminal/TerminalProcessExec.test.ts",
        "e2e/src/suite/integrations/terminal/TerminalProcess.test.ts",
        "e2e/src/suite/integrations/editor/DiffViewProvider.test.ts",
        "e2e/src/suite/core/webview/TheaTaskStack.test.ts",
        "e2e/src/suite/core/webview/TheaStateManager.test.ts",
        "e2e/src/suite/core/webview/TheaApiManager.test.ts",
        "e2e/src/suite/core/webview/history/TheaTaskHistory.io-cleanup.test.ts",
        "e2e/src/suite/core/tools/executeCommandTool.test.ts",
        "e2e/src/suite/core/tools/attemptCompletionTool.flow.test.ts",
        "e2e/src/suite/core/mentions/index.test.ts",
        "e2e/src/suite/core/diff/strategies/unified.test.ts",
        "e2e/src/suite/core/diff/strategies/new-unified.test.ts",
        "e2e/src/suite/core/diff/strategies/multi-search-replace.test.ts",
        "e2e/src/suite/core/config/importExport.test.ts",
        "e2e/src/suite/core/config/ContextProxy.test.ts",
        "e2e/src/suite/api/provider-enablement-validation.test.ts",
        "e2e/src/suite/api/transform/simple-format.test.ts",
        "e2e/src/suite/api/transform/openrouter.test.ts",
        "e2e/src/suite/api/transform/neutral-ollama-format.test.ts",
        "e2e/src/suite/api/providers/vertex.edge-cases.test.ts",
        "e2e/src/suite/api/providers/openai.edge-cases.test.ts",
        "e2e/src/suite/api/providers/openai-native.test.ts",
        "e2e/src/suite/api/providers/model-registry.test.ts",
        "e2e/src/suite/api/providers/bedrock.edge-cases.test.ts",
        "e2e/src/suite/api/providers/base-provider.schema-only.test.ts",
        "e2e/src/suite/api/providers/anthropic.edge-cases.test.ts",
        "e2e/src/suite/api/providers/all-dynamic-providers.runtime.test.ts"
      ],
      "totalCount": 65,
      "description": "Import statements after code has started"
    },
    "malformedCommentImport": {
      "files": [
        "e2e/src/suite/utils/port-utils.retry-timeout.test.ts",
        "e2e/src/suite/utils/json-xml-bridge.edge-cases.test.ts",
        "e2e/src/suite/services/mcp/transport/StdioTransport.lifecycle.test.ts",
        "e2e/src/suite/services/mcp/transport/StdioTransport.fallback.test.ts",
        "e2e/src/suite/services/mcp/transport/SseTransport.lifecycle.test.ts",
        "e2e/src/suite/services/mcp/providers/EmbeddedMcpProvider.lifecycle.test.ts",
        "e2e/src/suite/services/mcp/core/McpToolRouter.round-trip.test.ts",
        "e2e/src/suite/services/mcp/core/McpToolRouter.lifecycle.test.ts",
        "e2e/src/suite/services/mcp/core/McpConverters.xml-escaping.test.ts",
        "e2e/src/suite/services/mcp/core/McpConverters.edge-cases.test.ts",
        "e2e/src/suite/services/mcp/__tests__/performance/PerformanceValidation.test.ts",
        "e2e/src/suite/services/mcp/__tests__/formats/OpenAIFunctionFormat.test.ts",
        "e2e/src/suite/core/tools/attemptCompletionTool.flow.test.ts",
        "e2e/src/suite/api/providers/vertex.edge-cases.test.ts",
        "e2e/src/suite/api/providers/openai.edge-cases.test.ts",
        "e2e/src/suite/api/providers/model-registry.test.ts",
        "e2e/src/suite/api/providers/bedrock.edge-cases.test.ts",
        "e2e/src/suite/api/providers/base-provider.schema-only.test.ts",
        "e2e/src/suite/api/providers/all-dynamic-providers.runtime.test.ts"
      ],
      "totalCount": 19,
      "description": "Import statement followed by comment block"
    },
    "inlineMockAssignments": {
      "files": [
        "e2e/src/suite/utils/port-utils.retry-timeout.test.ts",
        "e2e/src/suite/services/mcp/ollama-mcp-integration.test.ts",
        "e2e/src/suite/services/mcp/McpIntegration.test.ts",
        "e2e/src/suite/services/mcp/McpHub.test.ts",
        "e2e/src/suite/services/mcp/McpConverters.test.ts",
        "e2e/src/suite/services/mcp/transport/StdioTransport.fallback.test.ts",
        "e2e/src/suite/services/mcp/core/McpToolRouter.test.ts",
        "e2e/src/suite/services/mcp/__tests__/performance/PerformanceValidation.test.ts",
        "e2e/src/suite/services/checkpoints/ShadowCheckpointService.test.ts",
        "e2e/src/suite/integrations/workspace/WorkspaceTracker.test.ts",
        "e2e/src/suite/integrations/misc/line-counter.test.ts",
        "e2e/src/suite/core/read-file-maxReadFileLine.test.ts",
        "e2e/src/suite/core/TheaTask.test.ts",
        "e2e/src/suite/core/CodeActionProvider2.test.ts",
        "e2e/src/suite/core/webview/TheaApiManager.test.ts",
        "e2e/src/suite/core/tools/attemptCompletionTool.flow.test.ts",
        "e2e/src/suite/core/prompts/system.test.ts",
        "e2e/src/suite/core/prompts/custom-system-prompt.test.ts",
        "e2e/src/suite/core/config/importExport.test.ts",
        "e2e/src/suite/core/config/ContextProxy.test.ts",
        "e2e/src/suite/api/ollama-integration.test.ts",
        "e2e/src/suite/api/providers/vscode-lm.test.ts",
        "e2e/src/suite/api/providers/vertex.test.ts",
        "e2e/src/suite/api/providers/vertex.edge-cases.test.ts",
        "e2e/src/suite/api/providers/requesty.test.ts",
        "e2e/src/suite/api/providers/openrouter.test.ts",
        "e2e/src/suite/api/providers/openai.edge-cases.test.ts",
        "e2e/src/suite/api/providers/bedrock.edge-cases.test.ts",
        "e2e/src/suite/api/providers/anthropic.edge-cases.test.ts"
      ],
      "totalCount": 82,
      "description": "Floating closing brackets from incomplete mocking"
    },
    "malformedTodoComment": {
      "files": [
        "e2e/src/suite/services/mcp/ollama-mcp-integration.test.ts",
        "e2e/src/suite/services/mcp/UnifiedMcpToolSystem.test.ts",
        "e2e/src/suite/services/mcp/McpIntegration.test.ts",
        "e2e/src/suite/services/mcp/transport/StdioTransport.lifecycle.test.ts",
        "e2e/src/suite/services/mcp/transport/SseTransport.lifecycle.test.ts",
        "e2e/src/suite/services/mcp/core/McpToolRouter.test.ts",
        "e2e/src/suite/services/mcp/core/McpToolExecutor.test.ts",
        "e2e/src/suite/services/mcp/__tests__/performance/PerformanceValidation.test.ts",
        "e2e/src/suite/integrations/misc/line-counter.test.ts",
        "e2e/src/suite/core/read-file-maxReadFileLine.test.ts",
        "e2e/src/suite/core/EditorUtils.test.ts",
        "e2e/src/suite/core/CodeActionProvider2.test.ts",
        "e2e/src/suite/core/webview/TheaMcpManager.test.ts",
        "e2e/src/suite/core/webview/TheaCacheManager.test.ts",
        "e2e/src/suite/core/prompts/system.test.ts",
        "e2e/src/suite/core/prompts/responses-theaignore.test.ts",
        "e2e/src/suite/core/ignore/TheaIgnoreController.test.ts",
        "e2e/src/suite/core/ignore/TheaIgnoreController.security.test.ts",
        "e2e/src/suite/api/transform/vscode-lm-format.test.ts",
        "e2e/src/suite/api/providers/vscode-lm.test.ts",
        "e2e/src/suite/api/providers/vertex.test.ts",
        "e2e/src/suite/api/providers/unbound.test.ts",
        "e2e/src/suite/api/providers/openai.edge-cases.test.ts"
      ],
      "totalCount": 29,
      "description": "Malformed TODO comment for proxyquire"
    },
    "mockImplementationOnce": {
      "files": [
        "e2e/src/suite/services/mcp/core/McpToolRouter.test.ts",
        "e2e/src/suite/api/providers/unbound.test.ts"
      ],
      "totalCount": 3,
      "description": "Jest mock methods needing conversion to sinon"
    },
    "testEachSyntax": {
      "files": [
        "e2e/src/suite/services/checkpoints/ShadowCheckpointService.test.ts"
      ],
      "totalCount": 1,
      "description": "Jest .each syntax that needs conversion"
    },
    "standaloneSetup": {
      "files": [
        "e2e/src/suite/api/providers/openai.test.ts",
        "e2e/src/suite/api/providers/openai-usage-tracking.test.ts",
        "e2e/src/suite/api/providers/openai-native.test.ts"
      ],
      "totalCount": 3,
      "description": "setup() outside of suite block"
    }
  },
  "analysisResults": {
    "e2e/src/suite/migrateSettings.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { fileExistsAtPath } from \"../utils/fs\"\nimport { GlobalFileNames } from \"../shared/globalFileNames\"\nimport { migrateSettings } from \"../utils/migrateSettings\"\nimport * as"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 1,
        "examples": [
          "expect("
        ]
      }
    ],
    "e2e/src/suite/NeutralVertexClient.test.ts": [
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          "  NeutralVertexClaudeResponse,\n  NeutralVertexGeminiResponse,\n} from \"../services/vertex/types\";\nimport "
        ]
      }
    ],
    "e2e/src/suite/utils/xml-matcher.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { XmlMatcher } from \"../xml-matcher\"\nimport * as"
        ]
      }
    ],
    "e2e/src/suite/utils/port-utils.retry-timeout.test.ts": [
      {
        "type": "malformedCommentImport",
        "description": "Import statement followed by comment block",
        "count": 1,
        "examples": [
          "import * as sinon from 'sinon'/**\n * port-utils retry and timeout tests\n * Tests retry logic, exponential backoff, timeout handling, and abort signals\n */"
        ]
      },
      {
        "type": "inlineMockAssignments",
        "description": "Floating closing brackets from incomplete mocking",
        "count": 2,
        "examples": [
          "}))",
          "}))"
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 2,
        "examples": [
          " * port-utils retry and timeout tests\n * Tests retry logic, exponential backoff, timeout handling, and abort signals\n */\n\nimport ",
          "\tisPortAvailable, \n\tfindAvailablePort, \n\twaitForPortAvailable, \n\twaitForPortInUse \n} from \"../port-utils\"\nimport "
        ]
      }
    ],
    "e2e/src/suite/utils/model-pattern-detection.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import {\nimport * as"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 60,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          "  isClaudeModel,\n  isClaude37Model,\n  isClaude35Model,\n  isClaudeOpusModel,\n  isClaudeHaikuModel,\n  isClaude3SonnetModel,\n  isThinkingModel,\n  isDeepSeekR1Model,\n  isO3MiniModel,\n  setCapabilitiesFromModelId,\n  getBaseModelId\n} from \"../model-pattern-detection\"\nimport "
        ]
      }
    ],
    "e2e/src/suite/utils/model-capabilities.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import {\nimport * as"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 33,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          "  supportsComputerUse,\n  supportsPromptCaching,\n  supportsImages,\n  supportsThinking,\n  supportsTemperature,\n  getMaxTokens,\n  getReasoningEffort,\n  hasCapability,\n  getContextWindowSize\n} from \"../model-capabilities\"\nimport "
        ]
      }
    ],
    "e2e/src/suite/utils/json-xml-bridge.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import {\nimport * as"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 36,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/utils/json-xml-bridge.edge-cases.test.ts": [
      {
        "type": "malformedCommentImport",
        "description": "Import statement followed by comment block",
        "count": 1,
        "examples": [
          "import * as sinon from 'sinon'/**\n * Edge case tests for JsonMatcher and FormatDetector\n * Tests buffer overflow, partial chunks, format detection\n */"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 17,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          " * Edge case tests for JsonMatcher and FormatDetector\n * Tests buffer overflow, partial chunks, format detection\n */\n\nimport "
        ]
      }
    ],
    "e2e/src/suite/utils/json-xml-bridge-jsonmatcher.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { JsonMatcher } from \"../json-xml-bridge\"\nimport * as"
        ]
      }
    ],
    "e2e/src/suite/utils/cost.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { calculateApiCostAnthropic, calculateApiCostOpenAI } from \"../cost\"\nimport { ModelInfo } from \"../../schemas\"\nimport * as"
        ]
      }
    ],
    "e2e/src/suite/utils/logging/CompactTransport.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { CompactTransport } from \"../CompactTransport\"\nimport { CompactLogEntry } from \"../types\"\nimport fs from \"fs\"\nimport path from \"path\"\n\nimport * as"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 6,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          "// __tests__/CompactTransport.test.ts\nimport "
        ]
      }
    ],
    "e2e/src/suite/test/dynamic-providers-mock.test.ts": [
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 18,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/test/generic-provider-mock/all-providers-runtime.test.ts": [
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 16,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/shared/vsCodeSelectorUtils.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { stringifyVsCodeLmModelSelector } from \"../vsCodeSelectorUtils\"\nimport { LanguageModelChatSelector } from \"vscode\"\n\nimport * as"
        ]
      }
    ],
    "e2e/src/suite/shared/support-prompts.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { supportPrompt } from \"../support-prompt\"\nimport * as"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 4,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/shared/modes.test.ts": [
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 39,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 2,
        "examples": [
          "// Mock setup must come before imports\n// TODO: Mock setup needs manual migration\nimport ",
          "const mockAddCustomInstructions = sinon.stub().resolves(\"Combined instructions\")\n// TODO: Mock setup needs manual migration\n// TODO: Mock needs manual migration\n// TODO: Implement proper mock with proxyquire\n\nimport "
        ]
      }
    ],
    "e2e/src/suite/shared/language.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { formatLanguage } from \"../language\"\n\nimport * as"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 6,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/shared/formatPath.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { formatPath } from \"../formatPath\"\n\nimport * as"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 2,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/shared/experiments.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { EXPERIMENT_IDS, experimentConfigsMap, experiments as Experiments, ExperimentId } from \"../experiments\"\n\nimport * as"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 4,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/shared/doesFileMatchRegex.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { doesFileMatchRegex } from \"../modes\"\n\nimport * as"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 3,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/shared/context-mentions.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { mentionRegex, mentionRegexGlobal } from \"../context-mentions\"\n\nimport * as"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 1,
        "examples": [
          "expect("
        ]
      }
    ],
    "e2e/src/suite/shared/checkExistApiConfig.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { checkExistKey } from \"../checkExistApiConfig\"\nimport { ApiConfiguration } from \"../api\"\n\nimport * as"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 6,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/services/checkpoints-excludes.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { join } from \"path\"\n\n// Import the functions we're testing  \nimport { getExcludePatterns } from \"../../../../services/checkpoints/excludes\"\nimport { GIT_DISABLED_SUFFIX } from \"../../../../services/checkpoints/constants\"\nimport * as"
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          "// Import the functions we're testing  \nimport "
        ]
      }
    ],
    "e2e/src/suite/services/tree-sitter/languageParser.test.ts": [
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 1,
        "examples": [
          "expect("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          "/* eslint-disable @typescript-eslint/unbound-method */\nimport "
        ]
      }
    ],
    "e2e/src/suite/services/tree-sitter/index.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { parseSourceCodeForDefinitionsTopLevel } from \"../index\"\nimport { listFiles } from \"../../glob/list-files\"\nimport { loadRequiredLanguageParsers } from \"../languageParser\"\nimport { fileExistsAtPath } from \"../../../utils/fs\"\nimport * as"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 2,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          "// Mock dependencies\n// TODO: Mock setup needs manual migration\n// TODO: Mock setup needs manual migration\n// TODO: Mock setup needs manual migration\n// TODO: Mock setup needs manual migration\nimport "
        ]
      }
    ],
    "e2e/src/suite/services/mcp/ollama-mcp-integration.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { McpClient } from \"../client/McpClient\"\nimport OpenAI from \"openai\"\nimport { McpIntegration } from \"../integration/McpIntegration\"\nimport { SseClientFactory } from \"../client/SseClientFactory\"\nimport { McpConverters } from \"../core/McpConverters\"\nimport * as"
        ]
      },
      {
        "type": "malformedTodoComment",
        "description": "Malformed TODO comment for proxyquire",
        "count": 1,
        "examples": [
          "// TODO: Use proxyquire for module mocking - \"openai\", () => {"
        ]
      },
      {
        "type": "inlineMockAssignments",
        "description": "Floating closing brackets from incomplete mocking",
        "count": 1,
        "examples": [
          "\t}))"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 1,
        "examples": [
          "expect("
        ]
      }
    ],
    "e2e/src/suite/services/mcp/UnifiedMcpToolSystem.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { McpToolExecutor } from \"../core/McpToolExecutor\"\nimport { NeutralToolResult, ToolUseFormat, NeutralToolUseRequest } from \"../types/McpToolTypes\"\nimport { McpConverters } from \"../core/McpConverters\"\nimport { McpToolRouter } from \"../core/McpToolRouter\"\nimport { IMcpProvider, ToolCallResult, ToolDefinition } from \"../types/McpProviderTypes\"\nimport { EventEmitter } from \"events\"\nimport * as"
        ]
      },
      {
        "type": "malformedTodoComment",
        "description": "Malformed TODO comment for proxyquire",
        "count": 2,
        "examples": [
          "// TODO: Use proxyquire for module mocking - \"../providers/EmbeddedMcpProvider\", () => {",
          "// TODO: Use proxyquire for module mocking - \"../core/McpToolRegistry\", () => {"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 1,
        "examples": [
          "expect("
        ]
      }
    ],
    "e2e/src/suite/services/mcp/SseTransport.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { EmbeddedMcpProvider } from \"../providers/EmbeddedMcpProvider\"\nimport { SseClientFactory } from \"../client/SseClientFactory\"\nimport { SseTransportConfig } from \"../transport/config/SseTransportConfig\"\nimport * as"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 2,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/services/mcp/McpToolRegistry.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { McpToolRegistry } from \"../core/McpToolRegistry\"\nimport { ToolDefinition } from \"../types/McpProviderTypes\"\nimport * as"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 9,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/services/mcp/McpIntegration.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { McpIntegration, handleToolUse } from \"../integration/McpIntegration\"\nimport * as"
        ]
      },
      {
        "type": "malformedTodoComment",
        "description": "Malformed TODO comment for proxyquire",
        "count": 2,
        "examples": [
          "// TODO: Use proxyquire for module mocking - \"../core/McpToolRouter\", () => {",
          "// TODO: Use proxyquire for module mocking - \"../core/McpToolExecutor\", () => {"
        ]
      },
      {
        "type": "inlineMockAssignments",
        "description": "Floating closing brackets from incomplete mocking",
        "count": 5,
        "examples": [
          "\t\t\t}))",
          "\t\t\t}))"
        ]
      }
    ],
    "e2e/src/suite/services/mcp/McpHub.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { ServerConfigSchema, McpHub } from \"../management/McpHub\"\nimport fs from \"fs/promises\"\nimport * as"
        ]
      },
      {
        "type": "inlineMockAssignments",
        "description": "Floating closing brackets from incomplete mocking",
        "count": 1,
        "examples": [
          "}))"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 6,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/services/mcp/McpConverters.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { McpConverters } from \"../core/McpConverters\"\nimport { ToolDefinition } from \"../types/McpProviderTypes\"\nimport { NeutralToolResult } from \"../types/McpToolTypes\"\nimport * as"
        ]
      },
      {
        "type": "inlineMockAssignments",
        "description": "Floating closing brackets from incomplete mocking",
        "count": 1,
        "examples": [
          "}))"
        ]
      }
    ],
    "e2e/src/suite/services/mcp/transport/StdioTransport.lifecycle.test.ts": [
      {
        "type": "malformedCommentImport",
        "description": "Import statement followed by comment block",
        "count": 1,
        "examples": [
          "import * as sinon from 'sinon'/**\n * Stdio Transport lifecycle tests as recommended by architect\n * Tests SDK import with fallback, stderr exposure, and handler management\n */"
        ]
      },
      {
        "type": "malformedTodoComment",
        "description": "Malformed TODO comment for proxyquire",
        "count": 2,
        "examples": [
          "// TODO: Use proxyquire dynamic mock - \"@modelcontextprotocol/sdk/server/stdio.js\", () => {",
          "// TODO: Use proxyquire dynamic mock - \"@modelcontextprotocol/sdk/server/stdio.js\", () => {"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 8,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          " * Stdio Transport lifecycle tests as recommended by architect\n * Tests SDK import with fallback, stderr exposure, and handler management\n */\n\nimport "
        ]
      }
    ],
    "e2e/src/suite/services/mcp/transport/StdioTransport.fallback.test.ts": [
      {
        "type": "malformedCommentImport",
        "description": "Import statement followed by comment block",
        "count": 1,
        "examples": [
          "import * as sinon from 'sinon'/**\n * StdioTransport fallback and mock stderr tests\n * Tests fallback behavior when SDK is not available, mock stderr handling, and error handlers\n */"
        ]
      },
      {
        "type": "inlineMockAssignments",
        "description": "Floating closing brackets from incomplete mocking",
        "count": 8,
        "examples": [
          "\t\t\t}))",
          "\t\t\t}))"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 10,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          " * StdioTransport fallback and mock stderr tests\n * Tests fallback behavior when SDK is not available, mock stderr handling, and error handlers\n */\n\nimport "
        ]
      }
    ],
    "e2e/src/suite/services/mcp/transport/SseTransport.lifecycle.test.ts": [
      {
        "type": "malformedCommentImport",
        "description": "Import statement followed by comment block",
        "count": 1,
        "examples": [
          "import * as sinon from 'sinon'/**\n * SSE Transport lifecycle tests as recommended by architect\n * Tests dynamic import, teardown guard, port management, and transport exposure\n */"
        ]
      },
      {
        "type": "malformedTodoComment",
        "description": "Malformed TODO comment for proxyquire",
        "count": 1,
        "examples": [
          "// TODO: Use proxyquire dynamic mock - \"@modelcontextprotocol/sdk/server/streamableHttp.js\", () => {"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 13,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          " * SSE Transport lifecycle tests as recommended by architect\n * Tests dynamic import, teardown guard, port management, and transport exposure\n */\n\nimport "
        ]
      }
    ],
    "e2e/src/suite/services/mcp/providers/MockMcpProvider.test.ts": [
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 6,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/services/mcp/providers/EmbeddedMcpProvider.lifecycle.test.ts": [
      {
        "type": "malformedCommentImport",
        "description": "Import statement followed by comment block",
        "count": 1,
        "examples": [
          "import * as sinon from 'sinon'/**\n * EmbeddedMcpProvider lifecycle tests as recommended by architect\n * Tests port management, restart behavior, events, and serverUrl\n */"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 13,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          " * EmbeddedMcpProvider lifecycle tests as recommended by architect\n * Tests port management, restart behavior, events, and serverUrl\n */\n\nimport "
        ]
      }
    ],
    "e2e/src/suite/services/mcp/performance/PerformanceValidation.test.ts": [
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 2,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 2,
        "examples": [
          "/**\n * Performance and streaming response validation tests for MCP system\n * Tests concurrent execution, memory usage, and response times\n */\nimport ",
          "/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-return, @typescript-eslint/no-require-imports, @typescript-eslint/require-await, @typescript-eslint/no-explicit-any, @typescript-eslint/restrict-template-expressions */\nimport "
        ]
      }
    ],
    "e2e/src/suite/services/mcp/integration/ProviderTransportIntegration.test.ts": [
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 8,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          "/**\n * Integration tests for provider-transport interactions\n * Tests MockMcpProvider scenarios and provider interface compliance\n */\n/* eslint-disable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/require-await, @typescript-eslint/restrict-template-expressions, @typescript-eslint/unbound-method */\nimport "
        ]
      }
    ],
    "e2e/src/suite/services/mcp/formats/OpenAIFunctionFormat.test.ts": [
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 4,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          "/**\n * Tests for OpenAI function format handling in MCP system\n * Validates conversion between OpenAI function calls and MCP neutral format\n */\n/* eslint-disable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-argument, @typescript-eslint/require-await, @typescript-eslint/no-explicit-any */\nimport "
        ]
      }
    ],
    "e2e/src/suite/services/mcp/e2e/ToolUseFlows.test.ts": [
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 2,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 2,
        "examples": [
          "/**\n * End-to-end tests for complete tool use flows\n * Tests the full pipeline from tool request to execution and response\n */\nimport ",
          "/* eslint-disable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-return, @typescript-eslint/no-require-imports, @typescript-eslint/require-await, @typescript-eslint/no-explicit-any, @typescript-eslint/restrict-template-expressions */\nimport "
        ]
      }
    ],
    "e2e/src/suite/services/mcp/core/McpToolRouter.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { EventEmitter } from \"events\"\nimport { McpToolRouter } from \"../McpToolRouter\"\nimport { McpToolExecutor } from \"../McpToolExecutor\"\nimport { McpConverters } from \"../McpConverters\"\nimport {\nimport * as"
        ]
      },
      {
        "type": "malformedTodoComment",
        "description": "Malformed TODO comment for proxyquire",
        "count": 2,
        "examples": [
          "// TODO: Use proxyquire for module mocking - \"../McpToolExecutor\", () => {",
          "// TODO: Use proxyquire for module mocking - \"../McpConverters\", () => {"
        ]
      },
      {
        "type": "inlineMockAssignments",
        "description": "Floating closing brackets from incomplete mocking",
        "count": 3,
        "examples": [
          "\t\t}))",
          "\t\t}))"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 1,
        "examples": [
          "expect("
        ]
      },
      {
        "type": "mockImplementationOnce",
        "description": "Jest mock methods needing conversion to sinon",
        "count": 2,
        "examples": [
          ".mockImplementationOnce(",
          ".mockImplementationOnce("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          "\tNeutralToolUseRequest,\n\tNeutralToolResult,\n\tToolUseFormat,\n\tToolUseRequestWithFormat,\n} from \"../../types/McpToolTypes\"\nimport "
        ]
      }
    ],
    "e2e/src/suite/services/mcp/core/McpToolRouter.round-trip.test.ts": [
      {
        "type": "malformedCommentImport",
        "description": "Import statement followed by comment block",
        "count": 1,
        "examples": [
          "import * as sinon from 'sinon'/**\n * Round-trip tests for McpToolRouter as recommended by architect\n * Tests that tool_use_id is preserved and formats are maintained\n */"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 4,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          " * Round-trip tests for McpToolRouter as recommended by architect\n * Tests that tool_use_id is preserved and formats are maintained\n */\n\nimport "
        ]
      }
    ],
    "e2e/src/suite/services/mcp/core/McpToolRouter.lifecycle.test.ts": [
      {
        "type": "malformedCommentImport",
        "description": "Import statement followed by comment block",
        "count": 1,
        "examples": [
          "import * as sinon from 'sinon'/**\n * McpToolRouter lifecycle tests\n * Tests initialization, shutdown, repeated start/stop, pending registrations, and event forwarding\n */"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 10,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          " * McpToolRouter lifecycle tests\n * Tests initialization, shutdown, repeated start/stop, pending registrations, and event forwarding\n */\n\nimport "
        ]
      }
    ],
    "e2e/src/suite/services/mcp/core/McpToolExecutor.test.ts": [
      {
        "type": "malformedTodoComment",
        "description": "Malformed TODO comment for proxyquire",
        "count": 2,
        "examples": [
          "// TODO: Use proxyquire for module mocking - \"../../providers/EmbeddedMcpProvider\", () => {",
          "// TODO: Use proxyquire for module mocking - \"../McpToolRegistry\", () => {"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 1,
        "examples": [
          "expect("
        ]
      }
    ],
    "e2e/src/suite/services/mcp/core/McpConverters.xml-escaping.test.ts": [
      {
        "type": "malformedCommentImport",
        "description": "Import statement followed by comment block",
        "count": 1,
        "examples": [
          "import * as sinon from 'sinon'/**\n * Comprehensive XML escaping and mixed content tests for McpConverters\n * Tests proper XML entity escaping, mixed content types, embedded quotes/newlines\n */"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 11,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          " * Comprehensive XML escaping and mixed content tests for McpConverters\n * Tests proper XML entity escaping, mixed content types, embedded quotes/newlines\n */\n\nimport "
        ]
      }
    ],
    "e2e/src/suite/services/mcp/core/McpConverters.test.ts": [
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 4,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/services/mcp/core/McpConverters.edge-cases.test.ts": [
      {
        "type": "malformedCommentImport",
        "description": "Import statement followed by comment block",
        "count": 1,
        "examples": [
          "import * as sinon from 'sinon'/**\n * Edge case tests for McpConverters as recommended by architect\n * Tests XML/JSON/OpenAI  neutral conversions with edge cases\n */"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 8,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          " * Edge case tests for McpConverters as recommended by architect\n * Tests XML/JSON/OpenAI  neutral conversions with edge cases\n */\n\nimport "
        ]
      }
    ],
    "e2e/src/suite/services/mcp/client/SseClientFactory.test.ts": [
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 2,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          "/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-require-imports, @typescript-eslint/no-explicit-any */\nimport "
        ]
      }
    ],
    "e2e/src/suite/services/mcp/__tests__/performance/PerformanceValidation.test.ts": [
      {
        "type": "malformedCommentImport",
        "description": "Import statement followed by comment block",
        "count": 1,
        "examples": [
          "import * as sinon from 'sinon'/**\n * Performance and streaming response validation tests for MCP system\n * Tests concurrent execution, memory usage, and response times\n */"
        ]
      },
      {
        "type": "malformedTodoComment",
        "description": "Malformed TODO comment for proxyquire",
        "count": 2,
        "examples": [
          "// TODO: Use proxyquire for module mocking - \"../../providers/EmbeddedMcpProvider\", () => {",
          "// TODO: Use proxyquire for module mocking - \"../../core/McpToolRegistry\", () => {"
        ]
      },
      {
        "type": "inlineMockAssignments",
        "description": "Floating closing brackets from incomplete mocking",
        "count": 2,
        "examples": [
          "\t\t\t\t\t}))",
          "\t\t\t\t\t}))"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 17,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 2,
        "examples": [
          " * Performance and streaming response validation tests for MCP system\n * Tests concurrent execution, memory usage, and response times\n */\nimport ",
          "/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-return, @typescript-eslint/no-require-imports, @typescript-eslint/require-await, @typescript-eslint/no-explicit-any, @typescript-eslint/restrict-template-expressions */\nimport "
        ]
      }
    ],
    "e2e/src/suite/services/mcp/__tests__/formats/OpenAIFunctionFormat.test.ts": [
      {
        "type": "malformedCommentImport",
        "description": "Import statement followed by comment block",
        "count": 1,
        "examples": [
          "import * as sinon from 'sinon'/**\n * Tests for OpenAI function format handling in MCP system\n * Validates conversion between OpenAI function calls and MCP neutral format\n */"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 6,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          " * Tests for OpenAI function format handling in MCP system\n * Validates conversion between OpenAI function calls and MCP neutral format\n */\n/* eslint-disable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-argument, @typescript-eslint/require-await, @typescript-eslint/no-explicit-any */\nimport "
        ]
      }
    ],
    "e2e/src/suite/services/checkpoints/excludes.test.ts": [
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 1,
        "examples": [
          "expect("
        ]
      }
    ],
    "e2e/src/suite/services/checkpoints/ShadowCheckpointService.test.ts": [
      {
        "type": "inlineMockAssignments",
        "description": "Floating closing brackets from incomplete mocking",
        "count": 1,
        "examples": [
          "}))"
        ]
      },
      {
        "type": "testEachSyntax",
        "description": "Jest .each syntax that needs conversion",
        "count": 1,
        "examples": [
          ".each("
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 35,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/schemas/index.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { GLOBAL_STATE_KEYS } from \"../index\"\n\nimport * as"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 1,
        "examples": [
          "expect("
        ]
      }
    ],
    "e2e/src/suite/integrations/workspace/WorkspaceTracker.test.ts": [
      {
        "type": "inlineMockAssignments",
        "description": "Floating closing brackets from incomplete mocking",
        "count": 6,
        "examples": [
          "}))",
          "}))"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 4,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/integrations/terminal/TerminalRegistry.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { TerminalRegistry } from \"../TerminalRegistry\"\nimport { EXTENSION_DISPLAY_NAME } from \"../../../shared/config/thea-config\"\n\n// Mock vscode.window.createTerminal\nimport * as"
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          "// Mock vscode.window.createTerminal\nimport "
        ]
      }
    ],
    "e2e/src/suite/integrations/terminal/TerminalProcessInterpretExitCode.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { TerminalProcess } from \"../TerminalProcess\"\nimport { execSync } from \"child_process\"\n\nimport * as"
        ]
      }
    ],
    "e2e/src/suite/integrations/terminal/TerminalProcessExec.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { execSync } from \"child_process\"\nimport { TerminalProcess, ExitCodeDetails } from \"../TerminalProcess\"\nimport { Terminal } from \"../Terminal\"\nimport { TerminalRegistry } from \"../TerminalRegistry\"\n// Mock the vscode module\n// TODO: Mock setup needs manual migration\nimport * as"
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          "// Mock the vscode module\n// TODO: Mock setup needs manual migration\nimport "
        ]
      }
    ],
    "e2e/src/suite/integrations/terminal/TerminalProcess.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { TerminalProcess, mergePromise } from \"../TerminalProcess\"\nimport { Terminal } from \"../Terminal\"\nimport { TerminalRegistry } from \"../TerminalRegistry\"\nimport { EXTENSION_DISPLAY_NAME } from \"../../../shared/config/thea-config\"\n\n// Mock vscode.window.createTerminal\nimport * as"
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          "// Mock vscode.window.createTerminal\nimport "
        ]
      }
    ],
    "e2e/src/suite/integrations/misc/read-lines.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { promises as fs } from \"fs\"\nimport path from \"path\"\nimport { readLines } from \"../read-lines\"\nimport * as"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 6,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/integrations/misc/line-counter.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { countFileLines } from \"../line-counter\"\nimport * as"
        ]
      },
      {
        "type": "malformedTodoComment",
        "description": "Malformed TODO comment for proxyquire",
        "count": 1,
        "examples": [
          "// TODO: Use proxyquire for module mocking - \"fs\", () => {"
        ]
      },
      {
        "type": "inlineMockAssignments",
        "description": "Floating closing brackets from incomplete mocking",
        "count": 1,
        "examples": [
          "}))"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 2,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/integrations/misc/extract-text.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import {\nimport * as"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 29,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/integrations/editor/detect-omission.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { detectCodeOmission } from \"../detect-omission\"\n\nimport * as"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 18,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/integrations/editor/DiffViewProvider.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { DiffViewProvider } from \"../DiffViewProvider\"\nimport * as"
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          "// Mock vscode\n// TODO: Mock setup needs manual migration\nimport "
        ]
      }
    ],
    "e2e/src/suite/core/read-file-tool.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { countFileLines } from \"../../integrations/misc/line-counter\"\nimport { readLines } from \"../../integrations/misc/read-lines\"\nimport { extractTextFromFile, addLineNumbers } from \"../../integrations/misc/extract-text\"\nimport * as"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 3,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/core/read-file-maxReadFileLine.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { countFileLines } from \"../../integrations/misc/line-counter\"\nimport { readLines } from \"../../integrations/misc/read-lines\"\nimport { extractTextFromFile, addLineNumbers } from \"../../integrations/misc/extract-text\"\nimport { parseSourceCodeDefinitionsForFile } from \"../../services/tree-sitter\"\nimport { isBinaryFile } from \"isbinaryfile\"\nimport { ReadFileToolUse } from \"../assistant-message\"\nimport * as"
        ]
      },
      {
        "type": "malformedTodoComment",
        "description": "Malformed TODO comment for proxyquire",
        "count": 1,
        "examples": [
          "// TODO: Use proxyquire for module mocking - \"path\", () => {"
        ]
      },
      {
        "type": "inlineMockAssignments",
        "description": "Floating closing brackets from incomplete mocking",
        "count": 3,
        "examples": [
          "}))",
          "}))"
        ]
      }
    ],
    "e2e/src/suite/core/parse-assistant-message.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { parseAssistantMessage } from \"../assistant-message/parse-assistant-message\"\nimport type { AccessMcpResourceToolUse } from \"../assistant-message\"\nimport * as"
        ]
      }
    ],
    "e2e/src/suite/core/mode-validator.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { isToolAllowedForMode, modes, ModeConfig } from \"../../shared/modes\"\nimport { TOOL_GROUPS } from \"../../shared/tool-groups\"\nimport { validateToolUse } from \"../mode-validator\"\nimport * as"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 22,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/core/access-mcp-resource-tool.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { accessMcpResourceTool } from \"../tools/accessMcpResourceTool\"\nimport type { RemoveClosingTag } from \"../tools/types\"\nimport * as"
        ]
      }
    ],
    "e2e/src/suite/core/TheaTask.test.ts": [
      {
        "type": "inlineMockAssignments",
        "description": "Floating closing brackets from incomplete mocking",
        "count": 1,
        "examples": [
          "\t\t\t}))"
        ]
      }
    ],
    "e2e/src/suite/core/EditorUtils.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { EditorUtils } from \"../EditorUtils\"\nimport * as"
        ]
      },
      {
        "type": "malformedTodoComment",
        "description": "Malformed TODO comment for proxyquire",
        "count": 1,
        "examples": [
          "// TODO: Use proxyquire for module mocking - \"vscode\", () => {"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 4,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/core/CodeActionProvider2.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { CodeActionProvider, ACTION_NAMES } from \"../CodeActionProvider\"\nimport { EditorUtils } from \"../EditorUtils\"\nimport * as"
        ]
      },
      {
        "type": "malformedTodoComment",
        "description": "Malformed TODO comment for proxyquire",
        "count": 1,
        "examples": [
          "// TODO: Use proxyquire for module mocking - \"vscode\", () => {"
        ]
      },
      {
        "type": "inlineMockAssignments",
        "description": "Floating closing brackets from incomplete mocking",
        "count": 1,
        "examples": [
          "}))"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 4,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/core/CodeActionProvider.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { CodeActionProvider, ACTION_NAMES } from \"../CodeActionProvider\"\nimport { EditorUtils } from \"../EditorUtils\"\n\nimport * as"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 4,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/core/webview/getNonce.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { getNonce } from \"../getNonce\"\nimport * as"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 3,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/core/webview/TheaTaskStack.test.ts": [
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 15,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          "/* eslint-disable @typescript-eslint/unbound-method */\nimport "
        ]
      }
    ],
    "e2e/src/suite/core/webview/TheaStateManager.test.ts": [
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          "// filepath: /Volumes/stuff/Projects/Thea-Code/src/core/webview/__tests__/ClineStateManager.test.ts\n/* eslint-disable @typescript-eslint/unbound-method */\nimport "
        ]
      }
    ],
    "e2e/src/suite/core/webview/TheaMcpManager.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { TheaMcpManager } from \"../mcp/TheaMcpManager\"\nimport { McpHub } from \"../../../services/mcp/management/McpHub\"\nimport { EXTENSION_DISPLAY_NAME, EXTENSION_CONFIG_DIR } from \"../../../shared/config/thea-config\"\nimport * as"
        ]
      },
      {
        "type": "malformedTodoComment",
        "description": "Malformed TODO comment for proxyquire",
        "count": 1,
        "examples": [
          "// TODO: Use proxyquire for module mocking - \"path\", () => {"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 4,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/core/webview/TheaCacheManager.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { TheaCacheManager } from \"../cache/TheaCacheManager\" // Updated import\nimport { fileExistsAtPath } from \"../../../utils/fs\"\nimport { ModelInfo } from \"../../../shared/api\"\nimport * as"
        ]
      },
      {
        "type": "malformedTodoComment",
        "description": "Malformed TODO comment for proxyquire",
        "count": 1,
        "examples": [
          "// TODO: Use proxyquire for module mocking - \"../../../shared/storagePathManager\", () => {"
        ]
      }
    ],
    "e2e/src/suite/core/webview/TheaApiManager.test.ts": [
      {
        "type": "inlineMockAssignments",
        "description": "Floating closing brackets from incomplete mocking",
        "count": 4,
        "examples": [
          "\t\t}))",
          "\t\t}))"
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 2,
        "examples": [
          "/* eslint-disable @typescript-eslint/unbound-method */\nimport ",
          "\tglamaDefaultModelId,\n\tglamaDefaultModelInfo,\n\trequestyDefaultModelId,\n\trequestyDefaultModelInfo,\n} from \"../../../shared/api\"\nimport "
        ]
      }
    ],
    "e2e/src/suite/core/webview/history/TheaTaskHistory.io-cleanup.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { TheaTaskHistory } from \"../TheaTaskHistory\"\nimport * as"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 9,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          "/**\n * TheaTaskHistory IO and cleanup tests\n * Tests file I/O operations, cleanup order, export paths, and error handling\n */\n\nimport "
        ]
      }
    ],
    "e2e/src/suite/core/tools/executeCommandTool.test.ts": [
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          "// TODO: Use proxyquire for module mocking - \"../../ignore/TheaIgnoreController\")\nimport "
        ]
      }
    ],
    "e2e/src/suite/core/tools/attemptCompletionTool.flow.test.ts": [
      {
        "type": "malformedCommentImport",
        "description": "Import statement followed by comment block",
        "count": 1,
        "examples": [
          "import * as sinon from 'sinon'/**\n * attemptCompletionTool partial/final flow tests\n * Tests partial completion, final completion, approval flows, and telemetry\n */"
        ]
      },
      {
        "type": "inlineMockAssignments",
        "description": "Floating closing brackets from incomplete mocking",
        "count": 1,
        "examples": [
          "\t\t\t\t}))"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 3,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          " * attemptCompletionTool partial/final flow tests\n * Tests partial completion, final completion, approval flows, and telemetry\n */\n\nimport "
        ]
      }
    ],
    "e2e/src/suite/core/sliding-window/sliding-window.test.ts": [
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 10,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/core/prompts/system.test.ts": [
      {
        "type": "malformedTodoComment",
        "description": "Malformed TODO comment for proxyquire",
        "count": 1,
        "examples": [
          "// TODO: Use proxyquire for module mocking - \"../sections/custom-instructions\", () => {"
        ]
      },
      {
        "type": "inlineMockAssignments",
        "description": "Floating closing brackets from incomplete mocking",
        "count": 4,
        "examples": [
          "}))",
          "}))"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 43,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/core/prompts/sections.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { addCustomInstructions } from \"../sections/custom-instructions\"\nimport { getCapabilitiesSection } from \"../sections/capabilities\"\nimport { DiffStrategy, DiffResult } from \"../../diff/types\"\nimport * as"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 4,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/core/prompts/responses-theaignore.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { formatResponse } from \"../responses\"\nimport { TheaIgnoreController, LOCK_TEXT_SYMBOL } from \"../../ignore/TheaIgnoreController\" // Keep original path, use renamed class\nimport { fileExistsAtPath } from \"../../../utils/fs\"\nimport { GLOBAL_FILENAMES } from \"../../../shared/config/thea-config\"\nimport * as"
        ]
      },
      {
        "type": "malformedTodoComment",
        "description": "Malformed TODO comment for proxyquire",
        "count": 1,
        "examples": [
          "// TODO: Use proxyquire for module mocking - \"vscode\", () => {"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 13,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/core/prompts/custom-system-prompt.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 2,
        "examples": [
          "import { SYSTEM_PROMPT } from \"../system\"\nimport { defaultModeSlug, modes } from \"../../../shared/modes\"\nimport * as",
          "import { toPosix } from \"./utils\"\nimport { EXTENSION_CONFIG_DIR } from \"../../../shared/config/thea-config\"\nimport * as"
        ]
      },
      {
        "type": "inlineMockAssignments",
        "description": "Floating closing brackets from incomplete mocking",
        "count": 2,
        "examples": [
          "}))",
          "}))"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 4,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/core/prompts/sections/custom-instructions.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { loadRuleFiles, addCustomInstructions } from \"../custom-instructions\"\nimport fs from \"fs/promises\"\nimport * as"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 4,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/core/mentions/index.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { parseMentions, openMention } from \"../index\"\nimport { UrlContentFetcher } from \"../../../services/browser/UrlContentFetcher\"\nimport * as"
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          "const createMockUri = (scheme: string, path: string) => ({\n\tscheme,\n\tauthority: \"\",\n\tpath,\n\tquery: \"\",\n\tfragment: \"\",\n\tfsPath: path,\n\twith: sinon.stub(),\n\ttoString: () => path,\n\ttoJSON: () => ({\n\t\tscheme,\n\t\tauthority: \"\",\n\t\tpath,\n\t\tquery: \"\",\n\t\tfragment: \"\",\n\t}),\n})\n\nconst mockExecuteCommand = sinon.stub()\nconst mockOpenExternal = sinon.stub()\nconst mockShowErrorMessage = sinon.stub()\n\nconst mockVscode = {\n\tworkspace: {\n\t\tworkspaceFolders: [\n\t\t\t{\n\t\t\t\turi: { fsPath: \"/test/workspace\" },\n\t\t\t},\n\t\t] as { uri: { fsPath: string } }[] | undefined,\n\t\tgetWorkspaceFolder: sinon.stub().returns(\"/test/workspace\"),\n\t\tfs: {\n\t\t\tstat: sinon.stub(),\n\t\t\twriteFile: sinon.stub(),\n\t\t},\n\t\topenTextDocument: sinon.stub().resolves({}),\n\t},\n\twindow: {\n\t\tshowErrorMessage: mockShowErrorMessage,\n\t\tshowInformationMessage: sinon.stub(),\n\t\tshowWarningMessage: sinon.stub(),\n\t\tcreateTextEditorDecorationType: sinon.stub(),\n\t\tcreateOutputChannel: sinon.stub(),\n\t\tcreateWebviewPanel: sinon.stub(),\n\t\tshowTextDocument: sinon.stub().resolves({}),\n\t\tactiveTextEditor: undefined as\n\t\t\t| undefined\n\t\t\t| {\n\t\t\t\t\tdocument: {\n\t\t\t\t\t\turi: { fsPath: string }\n\t\t\t\t\t}\n\t\t\t  },\n\t},\n\tcommands: {\n\t\texecuteCommand: mockExecuteCommand,\n\t},\n\tenv: {\n\t\topenExternal: mockOpenExternal,\n\t},\n\tUri: {\n\t\tparse: sinon.stub((url: string) => createMockUri(\"https\", url)),\n\t\tfile: sinon.stub((path: string) => createMockUri(\"file\", path)),\n\t},\n\tPosition: sinon.stub(),\n\tRange: sinon.stub(),\n\tTextEdit: sinon.stub(),\n\tWorkspaceEdit: sinon.stub(),\n\tDiagnosticSeverity: {\n\t\tError: 0,\n\t\tWarning: 1,\n\t\tInformation: 2,\n\t\tHint: 3,\n\t},\n}\n\n// Mock modules\n// TODO: Use proxyquire for module mocking - \"vscode\", () => mockVscode)\n// TODO: Use proxyquire for module mocking - \"../../../services/browser/UrlContentFetcher\")\n// TODO: Use proxyquire for module mocking - \"../../../utils/git\")\n// TODO: Use proxyquire for module mocking - \"../../../utils/path\")\n\n// Now import the modules that use the mocks\nimport "
        ]
      }
    ],
    "e2e/src/suite/core/ignore/TheaIgnoreController.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { TheaIgnoreController, LOCK_TEXT_SYMBOL } from \"../TheaIgnoreController\" // Use renamed class, keep original path\nimport * as"
        ]
      },
      {
        "type": "malformedTodoComment",
        "description": "Malformed TODO comment for proxyquire",
        "count": 1,
        "examples": [
          "// TODO: Use proxyquire for module mocking - \"vscode\", () => {"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 44,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/core/ignore/TheaIgnoreController.security.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { TheaIgnoreController } from \"../TheaIgnoreController\"\nimport * as"
        ]
      },
      {
        "type": "malformedTodoComment",
        "description": "Malformed TODO comment for proxyquire",
        "count": 1,
        "examples": [
          "// TODO: Use proxyquire for module mocking - \"vscode\", () => {"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 54,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/core/diff/strategies/unified.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { UnifiedDiffStrategy } from \"../unified\"\n\nimport * as"
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 2,
        "examples": [
          "suite(\"UnifiedDiffStrategy\", () => {\n\tlet strategy: UnifiedDiffStrategy\n\n\tsetup(() => {\n\t\tstrategy = new UnifiedDiffStrategy()\n\n\tsuite(\"getToolDescription\", () => {\n\t\ttest(\"should return tool description with correct cwd\", () => {\n\t\t\tconst cwd = \"/test/path\"\n\t\t\tconst description = strategy.getToolDescription({ cwd })\n\n\t\t\tassert.ok(description.includes(\"apply_diff\"))\n\t\t\tassert.ok(description.includes(cwd))\n\t\t\tassert.ok(description.includes(\"Parameters:\"))\n\t\t\tassert.ok(description.includes(\"Format Requirements:\"))\n\n\tsuite(\"applyDiff\", () => {\n\t\ttest.skip(\"should successfully apply a function modification diff\", async () => {\n\t\t\tconst originalContent = `import type { Logger } from \"../logger\";\n\nfunction calculateTotal(items: number[]): number {\n  return items.reduce((sum, item) => {\n    return sum + item;\n  }, 0);\n\nexport { calculateTotal };`\n\n\t\t\tconst diffContent = `--- src/utils/helper.ts\n+++ src/utils/helper.ts\n@@ -1,9 +1,10 @@\n import type { Logger } from \"../logger\";\n \n function calculateTotal(items: number[]): number {\n-  return items.reduce((sum, item) => {\n-    return sum + item;\n+  const total = items.reduce((sum, item) => {\n+    return sum + item * 1.1;  // Add 10% markup\n   }, 0);\n+  return Math.round(total * 100) / 100;  // Round to 2 decimal places\n\n export { calculateTotal };`\n\n\t\t\tconst expected = `import type { Logger } from \"../logger\";\n\nfunction calculateTotal(items: number[]): number {\n  const total = items.reduce((sum, item) => {\n    return sum + item * 1.1;  // Add 10% markup\n  }, 0);\n  return Math.round(total * 100) / 100;  // Round to 2 decimal places\n\nexport { calculateTotal };`\n\n\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\tassert.strictEqual(result.success, true)\n\t\t\tif (result.success) {\n\t\t\t\tassert.strictEqual(result.content, expected)\n\n\t\ttest.skip(\"should successfully apply a diff adding a new method\", async () => {\n\t\t\tconst originalContent = `class Calculator {\n  add(a: number, b: number): number {\n    return a + b;\n\n}`\n\n\t\t\tconst diffContent = `--- src/Calculator.ts\n+++ src/Calculator.ts\n@@ -1,5 +1,9 @@\n class Calculator {\n   add(a: number, b: number): number {\n     return a + b;\n\n+\n+  multiply(a: number, b: number): number {\n+    return a * b;\n+  }\n }`\n\n\t\t\tconst expected = `class Calculator {\n  add(a: number, b: number): number {\n    return a + b;\n\n  multiply(a: number, b: number): number {\n    return a * b;\n\n}`\n\n\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\tassert.strictEqual(result.success, true)\n\t\t\tif (result.success) {\n\t\t\t\tassert.strictEqual(result.content, expected)\n\n\t\ttest.skip(\"should successfully apply a diff modifying imports\", async () => {\n\t\t\tconst originalContent = `import { useState } from 'react';\nimport ",
          "function App() {\n  const [count, setCount] = useState(0);\n  return <Button onClick={() => setCount(count + 1)}>{count}</Button>;\n}`\n\n\t\t\tconst diffContent = `--- src/App.tsx\n+++ src/App.tsx\n@@ -1,7 +1,8 @@\n-import { useState } from 'react';\n+import { useState, useEffect } from 'react';\n import { Button } from './components';\n \n function App() {\n   const [count, setCount] = useState(0);\n+  useEffect(() => { document.title = \\`Count: \\${count}\\` }, [count]);\n   return <Button onClick={() => setCount(count + 1)}>{count}</Button>;\n }`\n\n\t\t\tconst expected = `import { useState, useEffect } from 'react';\n\nfunction App() {\n  const [count, setCount] = useState(0);\n  useEffect(() => { document.title = \\`Count: \\${count}\\` }, [count]);\n  return <Button onClick={() => setCount(count + 1)}>{count}</Button>;\n}`\n\n\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\tassert.strictEqual(result.success, true)\n\t\t\tif (result.success) {\n\t\t\t\tassert.strictEqual(result.content, expected)\n\n\t\ttest.skip(\"should successfully apply a diff with multiple hunks\", async () => {\n\t\t\tconst originalContent = `import { readFile, writeFile } from 'fs';\n\nfunction processFile(path: string) {\n  readFile(path, 'utf8', (err, data) => {\n    if (err) throw err;\n    const processed = data.toUpperCase();\n    writeFile(path, processed, (err) => {\n      if (err) throw err;\n    });\n  });\n\nexport { processFile };`\n\n\t\t\tconst diffContent = `--- src/file-processor.ts\n+++ src/file-processor.ts\n@@ -1,12 +1,14 @@\n-import { readFile, writeFile } from 'fs';\n+import { promises as fs } from 'fs';\n+import { join } from 'path';\n \n-function processFile(path: string) {\n-  readFile(path, 'utf8', (err, data) => {\n-    if (err) throw err;\n+async function processFile(path: string) {\n+  try {\n+    const data = await fs.readFile(join(__dirname, path), 'utf8');\n     const processed = data.toUpperCase();\n-    writeFile(path, processed, (err) => {\n-      if (err) throw err;\n-    });\n-  });\n+    await fs.writeFile(join(__dirname, path), processed);\n+  } catch (error) {\n+    console.error('Failed to process file:', error);\n+    throw error;\n+  }\n\n export { processFile };`\n\n\t\t\tconst expected = `import { promises as fs } from 'fs';\nimport "
        ]
      }
    ],
    "e2e/src/suite/core/diff/strategies/new-unified.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { NewUnifiedDiffStrategy } from \"../new-unified\"\n\nimport * as"
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 2,
        "examples": [
          "suite(\"main\", () => {\n\tlet strategy: NewUnifiedDiffStrategy\n\n\tsetup(() => {\n\t\tstrategy = new NewUnifiedDiffStrategy(0.95) // Adjusted threshold for cmpstr\n\n\tsuite(\"constructor\", () => {\n\t\ttest(\"should use default confidence threshold when not provided\", () => {\n\t\t\tconst defaultStrategy = new NewUnifiedDiffStrategy()\n\t\t\tassert.strictEqual(defaultStrategy[\"confidenceThreshold\"], 1)\n\n\t\ttest(\"should use provided confidence threshold\", () => {\n\t\t\tconst customStrategy = new NewUnifiedDiffStrategy(0.85)\n\t\t\tassert.strictEqual(customStrategy[\"confidenceThreshold\"], 0.85)\n\n\t\ttest(\"should enforce minimum confidence threshold\", () => {\n\t\t\tconst lowStrategy = new NewUnifiedDiffStrategy(0.7) // Below minimum of 0.8\n\t\t\tassert.strictEqual(lowStrategy[\"confidenceThreshold\"], 0.8)\n\n\tsuite(\"getToolDescription\", () => {\n\t\ttest(\"should return tool description with correct cwd\", () => {\n\t\t\tconst cwd = \"/test/path\"\n\t\t\tconst description = strategy.getToolDescription({ cwd })\n\n\t\t\tassert.ok(description.includes(\"apply_diff Tool - Generate Precise Code Changes\"))\n\t\t\tassert.ok(description.includes(cwd))\n\t\t\tassert.ok(description.includes(\"Step-by-Step Instructions\"))\n\t\t\tassert.ok(description.includes(\"Requirements\"))\n\t\t\tassert.ok(description.includes(\"Examples\"))\n\t\t\tassert.ok(description.includes(\"Parameters:\"))\n\n\ttest(\"should apply simple diff correctly\", async () => {\n\t\tconst original = `line1\nline2\nline3`\n\n\t\tconst diff = `--- a/file.txt\n+++ b/file.txt\n@@ ... @@\n line1\n+new line\n line2\n-line3\n+modified line3`\n\n\t\tconst result = await strategy.applyDiff(original, diff)\n\t\tassert.strictEqual(result.success, true)\n\t\tif (result.success) {\n\t\t\tassert.strictEqual(result.content, `line1\nnew line\nline2\nmodified line3`)\n\n\ttest(\"should handle multiple hunks\", async () => {\n\t\tconst original = `line1\nline2\nline3\nline4\nline5`\n\n\t\tconst diff = `--- a/file.txt\n+++ b/file.txt\n@@ ... @@\n line1\n+new line\n line2\n-line3\n+modified line3\n@@ ... @@\n line4\n-line5\n+modified line5\n+new line at end`\n\n\t\tconst result = await strategy.applyDiff(original, diff)\n\t\tassert.strictEqual(result.success, true)\n\t\tif (result.success) {\n\t\t\tassert.strictEqual(result.content, `line1\nnew line\nline2\nmodified line3\nline4\nmodified line5\nnew line at end`)\n\n\ttest(\"should handle complex large\", async () => {\n\t\tconst original = `line1\nline2\nline3\nline4\nline5\nline6\nline7\nline8\nline9\nline10`\n\n\t\tconst diff = `--- a/file.txt\n+++ b/file.txt\n@@ ... @@\n line1\n+header line\n+another header\n line2\n-line3\n-line4\n+modified line3\n+modified line4\n+extra line\n@@ ... @@\n line6\n+middle section\n line7\n-line8\n+changed line8\n+bonus line\n@@ ... @@\n line9\n-line10\n+final line\n+very last line`\n\n\t\tconst result = await strategy.applyDiff(original, diff)\n\t\tassert.strictEqual(result.success, true)\n\t\tif (result.success) {\n\t\t\tassert.strictEqual(result.content, `line1\nheader line\nanother header\nline2\nmodified line3\nmodified line4\nextra line\nline5\nline6\nmiddle section\nline7\nchanged line8\nbonus line\nline9\nfinal line\nvery last line`)\n\n\ttest(\"should handle indentation changes\", async () => {\n\t\tconst original = `first line\n  indented line\n    double indented line\n  back to single indent\nno indent\n  indented again\n    double indent again\n      triple indent\n  back to single\nlast line`\n\n\t\tconst diff = `--- original\n+++ modified\n@@ ... @@\n first line\n   indented line\n+\ttab indented line\n+  new indented line\n     double indented line\n   back to single indent\n no indent\n   indented again\n     double indent again\n-      triple indent\n+      hi there mate\n   back to single\n last line`\n\n\t\tconst expected = `first line\n  indented line\n\ttab indented line\n  new indented line\n    double indented line\n  back to single indent\nno indent\n  indented again\n    double indent again\n      hi there mate\n  back to single\nlast line`\n\n\t\tconst result = await strategy.applyDiff(original, diff)\n\t\tassert.strictEqual(result.success, true)\n\t\tif (result.success) {\n\t\t\tassert.strictEqual(result.content, expected)\n\n\ttest(\"should handle high level edits\", async () => {\n\t\tconst original = `def factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)`\n\t\tconst diff = `@@ ... @@\n-def factorial(n):\n-    if n == 0:\n-        return 1\n-    else:\n-        return n * factorial(n-1)\n+def factorial(number):\n+    if number == 0:\n+        return 1\n+    else:\n+        return number * factorial(number-1)`\n\n\t\tconst expected = `def factorial(number):\n    if number == 0:\n        return 1\n    else:\n        return number * factorial(number-1)`\n\n\t\tconst result = await strategy.applyDiff(original, diff)\n\t\tassert.strictEqual(result.success, true)\n\t\tif (result.success) {\n\t\t\tassert.strictEqual(result.content, expected)\n\n\ttest(\"it should handle very complex edits\", async () => {\n\t\tconst original = `//Initialize the array that will hold the primes\nvar primeArray = [];\n/*Write a function that checks for primeness and\n pushes those values to t*he array*/\nfunction PrimeCheck(candidate){\n  isPrime = true;\n  for(var i = 2; i < candidate && isPrime; i++){\n    if(candidate%i === 0){\n      isPrime = false;\n    } else {\n      isPrime = true;\n\n  if(isPrime){\n    primeArray.push(candidate);\n\n  return primeArray;\n\n/*Write the code that runs the above until the\n l ength of the array equa*ls the number of primes\n desired*/\n\nvar numPrimes = prompt(\"How many primes?\");\n\n//Display the finished array of primes\n\n//for loop starting at 2 as that is the lowest prime number keep going until the array is as long as we requested\nfor (var i = 2; primeArray.length < numPrimes; i++) {\n  PrimeCheck(i); //\n\nconsole.log(primeArray);\n`\n\n\t\tconst diff = `--- test_diff.js\n+++ test_diff.js\n@@ ... @@\n-//Initialize the array that will hold the primes\n var primeArray = [];\n-/*Write a function that checks for primeness and\n- pushes those values to t*he array*/\n function PrimeCheck(candidate){\n   isPrime = true;\n   for(var i = 2; i < candidate && isPrime; i++){\n@@ ... @@\n   return primeArray;\n\n-/*Write the code that runs the above until the\n-  l ength of the array equa*ls the number of primes\n-  desired*/\n \n var numPrimes = prompt(\"How many primes?\");\n \n-//Display the finished array of primes\n-\n-//for loop starting at 2 as that is the lowest prime number keep going until the array is as long as we requested\n for (var i = 2; primeArray.length < numPrimes; i++) {\n-  PrimeCheck(i); //\n+  PrimeCheck(i);\n\n console.log(primeArray);`\n\n\t\tconst expected = `var primeArray = [];\nfunction PrimeCheck(candidate){\n  isPrime = true;\n  for(var i = 2; i < candidate && isPrime; i++){\n    if(candidate%i === 0){\n      isPrime = false;\n    } else {\n      isPrime = true;\n\n  if(isPrime){\n    primeArray.push(candidate);\n\n  return primeArray;\n\nvar numPrimes = prompt(\"How many primes?\");\n\nfor (var i = 2; primeArray.length < numPrimes; i++) {\n  PrimeCheck(i);\n\nconsole.log(primeArray);\n`\n\n\t\tconst result = await strategy.applyDiff(original, diff)\n\t\tassert.strictEqual(result.success, true)\n\t\tif (result.success) {\n\t\t\tassert.strictEqual(result.content, expected)\n\n\tsuite(\"error handling and edge cases\", () => {\n\t\ttest(\"should reject completely invalid diff format\", async () => {\n\t\t\tconst original = \"line1\\nline2\\nline3\"\n\t\t\tconst invalidDiff = \"this is not a diff at all\"\n\n\t\t\tconst result = await strategy.applyDiff(original, invalidDiff)\n\t\t\tassert.strictEqual(result.success, false)\n\n\t\ttest(\"should reject diff with invalid hunk format\", async () => {\n\t\t\tconst original = \"line1\\nline2\\nline3\"\n\t\t\tconst invalidHunkDiff = `--- a/file.txt\n+++ b/file.txt\ninvalid hunk header\n line1\n-line2\n+new line`\n\n\t\t\tconst result = await strategy.applyDiff(original, invalidHunkDiff)\n\t\t\tassert.strictEqual(result.success, false)\n\n\t\ttest(\"should fail when diff tries to modify non-existent content\", async () => {\n\t\t\tconst original = \"line1\\nline2\\nline3\"\n\t\t\tconst nonMatchingDiff = `--- a/file.txt\n+++ b/file.txt\n@@ ... @@\n line1\n-nonexistent line\n+new line\n line3`\n\n\t\t\tconst result = await strategy.applyDiff(original, nonMatchingDiff)\n\t\t\tassert.strictEqual(result.success, false)\n\n\t\ttest(\"should handle overlapping hunks\", async () => {\n\t\t\tconst original = `line1\nline2\nline3\nline4\nline5`\n\t\t\tconst overlappingDiff = `--- a/file.txt\n+++ b/file.txt\n@@ ... @@\n line1\n line2\n-line3\n+modified3\n line4\n@@ ... @@\n line2\n-line3\n-line4\n+modified3and4\n line5`\n\n\t\t\tconst result = await strategy.applyDiff(original, overlappingDiff)\n\t\t\tassert.strictEqual(result.success, false)\n\n\t\ttest(\"should handle empty lines modifications\", async () => {\n\t\t\tconst original = `line1\n\nline3\n\nline5`\n\t\t\tconst emptyLinesDiff = `--- a/file.txt\n+++ b/file.txt\n@@ ... @@\n line1\n\n-line3\n+line3modified\n\n line5`\n\n\t\t\tconst result = await strategy.applyDiff(original, emptyLinesDiff)\n\t\t\tassert.strictEqual(result.success, true)\n\t\t\tif (result.success) {\n\t\t\t\tassert.strictEqual(result.content, `line1\n\nline3modified\n\nline5`)\n\n\t\ttest(\"should handle mixed line endings in diff\", async () => {\n\t\t\tconst original = \"line1\\r\\nline2\\nline3\\r\\n\"\n\t\t\tconst mixedEndingsDiff = `--- a/file.txt\n+++ b/file.txt\n@@ ... @@\n line1\\r\n-line2\n+modified2\\r\n line3`\n\n\t\t\tconst result = await strategy.applyDiff(original, mixedEndingsDiff)\n\t\t\tassert.strictEqual(result.success, true)\n\t\t\tif (result.success) {\n\t\t\t\tassert.strictEqual(result.content, \"line1\\r\\nmodified2\\r\\nline3\\r\\n\")\n\n\t\ttest(\"should handle partial line modifications\", async () => {\n\t\t\tconst original = \"const value = oldValue + 123;\"\n\t\t\tconst partialDiff = `--- a/file.txt\n+++ b/file.txt\n@@ ... @@\n-const value = oldValue + 123;\n+const value = newValue + 123;`\n\n\t\t\tconst result = await strategy.applyDiff(original, partialDiff)\n\t\t\tassert.strictEqual(result.success, true)\n\t\t\tif (result.success) {\n\t\t\t\tassert.strictEqual(result.content, \"const value = newValue + 123;\")\n\n\t\ttest(\"should handle slightly malformed but recoverable diff\", async () => {\n\t\t\tconst original = \"line1\\nline2\\nline3\"\n\t\t\t// Missing space after --- and +++\n\t\t\tconst slightlyBadDiff = `---a/file.txt\n+++b/file.txt\n@@ ... @@\n line1\n-line2\n+new line\n line3`\n\n\t\t\tconst result = await strategy.applyDiff(original, slightlyBadDiff)\n\t\t\tassert.strictEqual(result.success, true)\n\t\t\tif (result.success) {\n\t\t\t\tassert.strictEqual(result.content, \"line1\\nnew line\\nline3\")\n\n\tsuite(\"similar code sections\", () => {\n\t\ttest(\"should correctly modify the right section when similar code exists\", async () => {\n\t\t\tconst original = `function add(a, b) {\n  return a + b;\n\nfunction subtract(a, b) {\n  return a - b;\n\nfunction multiply(a, b) {\n  return a + b;  // Bug here\n}`\n\n\t\t\tconst diff = `--- a/math.js\n+++ b/math.js\n@@ ... @@\n function multiply(a, b) {\n-  return a + b;  // Bug here\n+  return a * b;\n }`\n\n\t\t\tconst result = await strategy.applyDiff(original, diff)\n\t\t\tassert.strictEqual(result.success, true)\n\t\t\tif (result.success) {\n\t\t\t\tassert.strictEqual(result.content, `function add(a, b) {\n  return a + b;\n\nfunction subtract(a, b) {\n  return a - b;\n\nfunction multiply(a, b) {\n  return a * b;\n}`)\n\n\t\ttest(\"should handle multiple similar sections with correct context\", async () => {\n\t\t\tconst original = `if (condition) {\n  doSomething();\n  doSomething();\n  doSomething();\n\nif (otherCondition) {\n  doSomething();\n  doSomething();\n  doSomething();\n}`\n\n\t\t\tconst diff = `--- a/file.js\n+++ b/file.js\n@@ ... @@\n if (otherCondition) {\n   doSomething();\n-  doSomething();\n+  doSomethingElse();\n   doSomething();\n }`\n\n\t\t\tconst result = await strategy.applyDiff(original, diff)\n\t\t\tassert.strictEqual(result.success, true)\n\t\t\tif (result.success) {\n\t\t\t\tassert.strictEqual(result.content, `if (condition) {\n  doSomething();\n  doSomething();\n  doSomething();\n\nif (otherCondition) {\n  doSomething();\n  doSomethingElse();\n  doSomething();\n}`)\n\n\tsuite(\"hunk splitting\", () => {\n\t\ttest(\"should handle large diffs with multiple non-contiguous changes\", async () => {\n\t\t\tconst original = `import { readFile } from 'fs';\nimport ",
          "const logger = new Logger();\n\nasync function processFile(filePath: string) {\n  try {\n    const data = await readFile(filePath, 'utf8');\n    logger.info('File read successfully');\n    return data;\n  } catch (error) {\n    logger.error('Failed to read file:', error);\n    throw error;\n\nfunction validateInput(input: string): boolean {\n  if (!input) {\n    logger.warn('Empty input received');\n    return false;\n\n  return input.length > 0;\n\nasync function writeOutput(data: string) {\n  logger.info('Processing output');\n  // TODO: Implement output writing\n  return Promise.resolve();\n\nfunction parseConfig(configPath: string) {\n  logger.debug('Reading config from:', configPath);\n  // Basic config parsing\n  return {\n    enabled: true,\n    maxRetries: 3\n  };\n\nexport {\n  processFile,\n  validateInput,\n  writeOutput,\n  parseConfig\n};`\n\n\t\t\tconst diff = `--- a/file.ts\n+++ b/file.ts\n@@ ... @@\n-import { readFile } from 'fs';\n+import { readFile, writeFile } from 'fs';\n import type { join } from \"path\";\n-import { Logger } from './logger';\n+import { Logger } from './utils/logger';\n+import { Config } from './types';\n \n-const logger = new Logger();\n+const logger = new Logger('FileProcessor');\n \n async function processFile(filePath: string) {\n   try {\n     const data = await readFile(filePath, 'utf8');\n-    logger.info('File read successfully');\n+    logger.info(\\`File \\${filePath} read successfully\\`);\n     return data;\n   } catch (error) {\n-    logger.error('Failed to read file:', error);\n+    logger.error(\\`Failed to read file \\${filePath}:\\`, error);\n     throw error;\n\n function validateInput(input: string): boolean {\n   if (!input) {\n-    logger.warn('Empty input received');\n+    logger.warn('Validation failed: Empty input received');\n     return false;\n\n-  return input.length > 0;\n+  return input.trim().length > 0;\n\n-async function writeOutput(data: string) {\n-  logger.info('Processing output');\n-  // TODO: Implement output writing\n-  return Promise.resolve();\n+async function writeOutput(data: string, outputPath: string) {\n+  try {\n+    await writeFile(outputPath, data, 'utf8');\n+    logger.info(\\`Output written to \\${outputPath}\\`);\n+  } catch (error) {\n+    logger.error(\\`Failed to write output to \\${outputPath}:\\`, error);\n+    throw error;\n+  }\n\n-function parseConfig(configPath: string) {\n-  logger.debug('Reading config from:', configPath);\n-  // Basic config parsing\n-  return {\n-    enabled: true,\n-    maxRetries: 3\n-  };\n+async function parseConfig(configPath: string): Promise<Config> {\n+  try {\n+    const configData = await readFile(configPath, 'utf8');\n+    logger.debug(\\`Reading config from \\${configPath}\\`);\n+    return JSON.parse(configData);\n+  } catch (error) {\n+    logger.error(\\`Failed to parse config from \\${configPath}:\\`, error);\n+    throw error;\n+  }\n\n export {\n   processFile,\n   validateInput,\n   writeOutput,\n-  parseConfig\n+  parseConfig,\n+  type Config\n };`\n\n\t\t\tconst expected = `import { readFile, writeFile } from 'fs';\nimport "
        ]
      }
    ],
    "e2e/src/suite/core/diff/strategies/multi-search-replace.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { MultiSearchReplaceDiffStrategy } from \"../multi-search-replace\"\n\nimport * as"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 11,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          "suite(\"MultiSearchReplaceDiffStrategy\", () => {\n\tsuite(\"validateMarkerSequencing\", () => {\n\t\tlet strategy: MultiSearchReplaceDiffStrategy\n\n\t\tsetup(() => {\n\t\t\tstrategy = new MultiSearchReplaceDiffStrategy()\n\n\t\ttest(\"validates correct marker sequence\", () => {\n\t\t\tconst diff = \"<<<<<<< SEARCH\\n\" + \"some content\\n\" + \"=======\\n\" + \"new content\\n\" + \">>>>>>> REPLACE\"\n\t\t\texpect(strategy[\"validateMarkerSequencing\"](diff).success).toBe(true)\n\n\t\ttest(\"validates multiple correct marker sequences\", () => {\n\n\t\t\tconst diff =\n\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\"content1\\n\" +\n\t\t\t\t\"=======\\n\" +\n\t\t\t\t\"new1\\n\" +\n\t\t\t\t\">>>>>>> REPLACE\\n\\n\" +\n\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\"content2\\n\" +\n\t\t\t\t\"=======\\n\" +\n\t\t\t\t\"new2\\n\" +\n\t\t\t\t\">>>>>>> REPLACE\"\n\t\t\texpect(strategy[\"validateMarkerSequencing\"](diff).success).toBe(true)\n\n\t\ttest(\"detects separator before search\", () => {\n\n\t\t\tconst diff = \"=======\\n\" + \"content\\n\" + \">>>>>>> REPLACE\"\n\t\t\tconst result = strategy[\"validateMarkerSequencing\"](diff)\n\t\t\tassert.strictEqual(result.success, false)\n\t\t\tassert.ok(result.error.includes(\"'=======' found in your diff content\"))\n\n\t\ttest(\"detects replace before separator\", () => {\n\n\t\t\tconst diff = \"<<<<<<< SEARCH\\n\" + \"content\\n\" + \">>>>>>> REPLACE\"\n\t\t\tconst result = strategy[\"validateMarkerSequencing\"](diff)\n\t\t\tassert.strictEqual(result.success, false)\n\t\t\tassert.ok(result.error.includes(\"'>>>>>>> REPLACE' found in your diff content\"))\n\n\t\ttest(\"detects incomplete sequence\", () => {\n\n\t\t\tconst diff = \"<<<<<<< SEARCH\\n\" + \"content\\n\" + \"=======\\n\" + \"new content\"\n\t\t\tconst result = strategy[\"validateMarkerSequencing\"](diff)\n\t\t\tassert.strictEqual(result.success, false)\n\t\t\tassert.ok(result.error.includes(\"Expected '>>>>>>> REPLACE' was not found\"))\n\n\t\tsuite(\"exact matching\", () => {\n\t\t\tlet strategy: MultiSearchReplaceDiffStrategy\n\n\t\t\tsetup(() => {\n\t\t\t\tstrategy = new MultiSearchReplaceDiffStrategy(1.0, 5) // Default 1.0 threshold for exact matching, 5 line buffer for tests\n\n\t\t\ttest(\"should replace matching content\", async () => {\n\t\t\t\tconst originalContent = 'function hello() {\\n    console.log(\"hello\")\\n}\\n'\n\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\nfunction hello() {\n    console.log(\"hello\")\n\n=======\nfunction hello() {\n    console.log(\"hello world\")\n\n>>>>>>> REPLACE`\n\n\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\tif (result.success) {\n\t\t\t\t\tassert.strictEqual(result.content, 'function hello() {\\n    console.log(\"hello world\")\\n}\\n')\n\n\t\t\ttest(\"should match content with different surrounding whitespace\", async () => {\n\n\t\t\t\tconst originalContent = \"\\nfunction example() {\\n    return 42;\\n}\\n\\n\"\n\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\nfunction example() {\n    return 42;\n\n=======\nfunction example() {\n    return 43;\n\n>>>>>>> REPLACE`\n\n\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\tif (result.success) {\n\t\t\t\t\tassert.strictEqual(result.content, \"\\nfunction example() {\\n    return 43;\\n}\\n\\n\")\n\n\t\t\ttest(\"should match content with different indentation in search block\", async () => {\n\n\t\t\t\tconst originalContent = \"    function test() {\\n        return true;\\n    }\\n\"\n\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\nfunction test() {\n    return true;\n\n=======\nfunction test() {\n    return false;\n\n>>>>>>> REPLACE`\n\n\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\tif (result.success) {\n\t\t\t\t\tassert.strictEqual(result.content, \"    function test() {\\n        return false;\\n    }\\n\")\n\n\t\t\ttest(\"should handle tab-based indentation\", async () => {\n\n\t\t\t\tconst originalContent = \"function test() {\\n\\treturn true;\\n}\\n\"\n\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\nfunction test() {\n\\treturn true;\n\n=======\nfunction test() {\n\\treturn false;\n\n>>>>>>> REPLACE`\n\n\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\tif (result.success) {\n\t\t\t\t\tassert.strictEqual(result.content, \"function test() {\\n\\treturn false;\\n}\\n\")\n\n\t\t\ttest(\"should preserve mixed tabs and spaces\", async () => {\n\n\t\t\t\tconst originalContent = \"\\tclass Example {\\n\\t    constructor() {\\n\\t\\tthis.value = 0;\\n\\t    }\\n\\t}\"\n\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\n\\tclass Example {\n\\t    constructor() {\n\\t\\tthis.value = 0;\n\\t    }\n\\t}\n=======\n\\tclass Example {\n\\t    constructor() {\n\\t\\tthis.value = 1;\n\\t    }\n\\t}\n>>>>>>> REPLACE`\n\n\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\tif (result.success) {\n\t\t\t\t\tassert.strictEqual(result.content, \n\t\t\t\t\t\t\"\\tclass Example {\\n\\t    constructor() {\\n\\t\\tthis.value = 1;\\n\\t    }\\n\\t}\",\n\n\t\t\ttest(\"should handle additional indentation with tabs\", async () => {\n\n\t\t\t\tconst originalContent = \"\\tfunction test() {\\n\\t\\treturn true;\\n\\t}\"\n\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\nfunction test() {\n\\treturn true;\n\n=======\nfunction test() {\n\\t// Add comment\n\\treturn false;\n\n>>>>>>> REPLACE`\n\n\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\tif (result.success) {\n\t\t\t\t\tassert.strictEqual(result.content, \"\\tfunction test() {\\n\\t\\t// Add comment\\n\\t\\treturn false;\\n\\t}\")\n\n\t\t\ttest(\"should preserve exact indentation characters when adding lines\", async () => {\n\n\t\t\t\tconst originalContent = \"\\tfunction test() {\\n\\t\\treturn true;\\n\\t}\"\n\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\n\\tfunction test() {\n\\t\\treturn true;\n\\t}\n=======\n\\tfunction test() {\n\\t\\t// First comment\n\\t\\t// Second comment\n\\t\\treturn true;\n\\t}\n>>>>>>> REPLACE`\n\n\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\tif (result.success) {\n\t\t\t\t\tassert.strictEqual(result.content, \n\t\t\t\t\t\t\"\\tfunction test() {\\n\\t\\t// First comment\\n\\t\\t// Second comment\\n\\t\\treturn true;\\n\\t}\",\n\n\t\t\ttest(\"should handle Windows-style CRLF line endings\", async () => {\n\n\t\t\t\tconst originalContent = \"function test() {\\r\\n    return true;\\r\\n}\\r\\n\"\n\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\nfunction test() {\n    return true;\n\n=======\nfunction test() {\n    return false;\n\n>>>>>>> REPLACE`\n\n\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\tif (result.success) {\n\t\t\t\t\tassert.strictEqual(result.content, \"function test() {\\r\\n    return false;\\r\\n}\\r\\n\")\n\n\t\t\ttest(\"should return false if search content does not match\", async () => {\n\n\t\t\t\tconst originalContent = 'function hello() {\\n    console.log(\"hello\")\\n}\\n'\n\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\nfunction hello() {\n    console.log(\"wrong\")\n\n=======\nfunction hello() {\n    console.log(\"hello world\")\n\n>>>>>>> REPLACE`\n\n\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\tassert.strictEqual(result.success, false)\n\n\t\t\ttest(\"should return false if diff format is invalid\", async () => {\n\n\t\t\t\tconst originalContent = 'function hello() {\\n    console.log(\"hello\")\\n}\\n'\n\t\t\t\tconst diffContent = `test.ts\\nInvalid diff format`\n\n\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\tassert.strictEqual(result.success, false)\n\n\t\t\ttest(\"should handle multiple lines with proper indentation\", async () => {\n\n\t\t\t\tconst originalContent =\n\t\t\t\t\t\"class Example {\\n    constructor() {\\n        this.value = 0\\n    }\\n\\n    getValue() {\\n        return this.value\\n    }\\n}\\n\"\n\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\n    getValue() {\n        return this.value\n\n=======\n    getValue() {\n        // Add logging\n        console.log(\"Getting value\")\n        return this.value\n\n>>>>>>> REPLACE`\n\n\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\tif (result.success) {\n\t\t\t\t\tassert.strictEqual(result.content, \n\t\t\t\t\t\t'class Example {\\n    constructor() {\\n        this.value = 0\\n    }\\n\\n    getValue() {\\n        // Add logging\\n        console.log(\"Getting value\")\\n        return this.value\\n    }\\n}\\n',\n\n\t\t\ttest(\"should preserve whitespace exactly in the output\", async () => {\n\n\t\t\t\tconst originalContent = \"    indented\\n        more indented\\n    back\\n\"\n\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\n    indented\n        more indented\n    back\n=======\n    modified\n        still indented\n    end\n>>>>>>> REPLACE`\n\n\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\tif (result.success) {\n\t\t\t\t\tassert.strictEqual(result.content, \"    modified\\n        still indented\\n    end\\n\")\n\n\t\t\ttest(\"should preserve indentation when adding new lines after existing content\", async () => {\n\n\t\t\t\tconst originalContent = \"\t\t\t\tonScroll={() => updateHighlights()}\"\n\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\n\t\t\t\tonScroll={() => updateHighlights()}\n=======\n\t\t\t\tonScroll={() => updateHighlights()}\n\t\t\t\tonDragOver={(e) => {\n\t\t\t\t\te.preventDefault()\n\t\t\t\t\te.stopPropagation()\n\t\t\t\t}}\n>>>>>>> REPLACE`\n\n\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\tif (result.success) {\n\t\t\t\t\tassert.strictEqual(result.content, \n\t\t\t\t\t\t\"\t\t\t\tonScroll={() => updateHighlights()}\\n\t\t\t\tonDragOver={(e) => {\\n\t\t\t\t\te.preventDefault()\\n\t\t\t\t\te.stopPropagation()\\n\t\t\t\t}}\",\n\n\t\t\ttest(\"should handle varying indentation levels correctly\", async () => {\n\n\t\t\t\tconst originalContent = `\nclass Example {\n    constructor() {\n        this.value = 0;\n        if (true) {\n            this.init();\n\n}`.trim()\n\n\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\n    class Example {\n        constructor() {\n            this.value = 0;\n            if (true) {\n                this.init();\n\n=======\n    class Example {\n        constructor() {\n            this.value = 1;\n            if (true) {\n                this.init();\n                this.setup();\n                this.validate();\n\n>>>>>>> REPLACE`.trim()\n\n\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\tif (result.success) {\n\t\t\t\t\tassert.strictEqual(result.content, \n\t\t\t\t\t\t`\nclass Example {\n    constructor() {\n        this.value = 1;\n        if (true) {\n            this.init();\n            this.setup();\n            this.validate();\n\n}`.trim(),\n\n\t\t\ttest(\"should handle mixed indentation styles in the same file\", async () => {\n\n\t\t\t\tconst originalContent = `class Example {\n    constructor() {\n        this.value = 0;\n        if (true) {\n            this.init();\n\n}`.trim()\n\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\n    constructor() {\n        this.value = 0;\n        if (true) {\n        this.init();\n\n=======\n    constructor() {\n        this.value = 1;\n        if (true) {\n        this.init();\n        this.validate();\n\n>>>>>>> REPLACE`\n\n\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\tif (result.success) {\n\t\t\t\t\tassert.strictEqual(result.content, `class Example {\n    constructor() {\n        this.value = 1;\n        if (true) {\n        this.init();\n        this.validate();\n\n}`)\n\n\t\t\ttest(\"should handle Python-style significant whitespace\", async () => {\n\n\t\t\t\tconst originalContent = `def example():\n    if condition:\n        do_something()\n        for item in items:\n            process(item)\n    return True`.trim()\n\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\n    if condition:\n        do_something()\n        for item in items:\n            process(item)\n=======\n    if condition:\n        do_something()\n        while items:\n            item = items.pop()\n            process(item)\n>>>>>>> REPLACE`\n\n\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\tif (result.success) {\n\t\t\t\t\tassert.strictEqual(result.content, `def example():\n    if condition:\n        do_something()\n        while items:\n            item = items.pop()\n            process(item)\n    return True`)\n\n\t\t\ttest(\"should preserve empty lines with indentation\", async () => {\n\n\t\t\t\tconst originalContent = `function test() {\n    const x = 1;\n\n    if (x) {\n        return true;\n\n}`.trim()\n\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\n    const x = 1;\n\n    if (x) {\n=======\n    const x = 1;\n\n    // Check x\n    if (x) {\n>>>>>>> REPLACE`\n\n\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\tif (result.success) {\n\t\t\t\t\tassert.strictEqual(result.content, `function test() {\n    const x = 1;\n\n    // Check x\n    if (x) {\n        return true;\n\n}`)\n\n\t\t\ttest(\"should handle indentation when replacing entire blocks\", async () => {\n\n\t\t\t\tconst originalContent = `class Test {\n    method() {\n        if (true) {\n            console.log(\"test\");\n\n}`.trim()\n\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\n    method() {\n        if (true) {\n            console.log(\"test\");\n\n=======\n    method() {\n        try {\n            if (true) {\n                console.log(\"test\");\n\n        } catch (e) {\n            console.error(e);\n\n>>>>>>> REPLACE`\n\n\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\tif (result.success) {\n\t\t\t\t\tassert.strictEqual(result.content, `class Test {\n    method() {\n        try {\n            if (true) {\n                console.log(\"test\");\n\n        } catch (e) {\n            console.error(e);\n\n}`)\n\n\t\t\ttest(\"should handle negative indentation relative to search content\", async () => {\n\n\t\t\t\tconst originalContent = `class Example {\n    constructor() {\n        if (true) {\n            this.init();\n            this.setup();\n\n}`.trim()\n\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\n            this.init();\n            this.setup();\n=======\n        this.init();\n        this.setup();\n>>>>>>> REPLACE`\n\n\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\tif (result.success) {\n\t\t\t\t\tassert.strictEqual(result.content, `class Example {\n    constructor() {\n        if (true) {\n        this.init();\n        this.setup();\n\n}`)\n\n\t\t\ttest(\"should handle extreme negative indentation (no indent)\", async () => {\n\n\t\t\t\tconst originalContent = `class Example {\n    constructor() {\n        if (true) {\n            this.init();\n\n}`.trim()\n\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\n            this.init();\n=======\nthis.init();\n>>>>>>> REPLACE`\n\n\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\tif (result.success) {\n\t\t\t\t\tassert.strictEqual(result.content, `class Example {\n    constructor() {\n        if (true) {\nthis.init();\n\n}`)\n\n\t\t\ttest(\"should handle mixed indentation changes in replace block\", async () => {\n\n\t\t\t\tconst originalContent = `class Example {\n    constructor() {\n        if (true) {\n            this.init();\n            this.setup();\n            this.validate();\n\n}`.trim()\n\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\n            this.init();\n            this.setup();\n            this.validate();\n=======\n        this.init();\n            this.setup();\n    this.validate();\n>>>>>>> REPLACE`\n\n\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\tif (result.success) {\n\t\t\t\t\tassert.strictEqual(result.content, `class Example {\n    constructor() {\n        if (true) {\n        this.init();\n            this.setup();\n    this.validate();\n\n}`)\n\n\t\t\ttest(\"should find matches from middle out\", async () => {\n\n\t\t\t\tconst originalContent = `\nfunction one() {\n    return \"target\";\n\nfunction two() {\n    return \"target\";\n\nfunction three() {\n    return \"target\";\n\nfunction four() {\n    return \"target\";\n\nfunction five() {\n    return \"target\";\n}`.trim()\n\n\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\n    return \"target\";\n=======\n    return \"updated\";\n>>>>>>> REPLACE`\n\n\t\t\t\t// Search around the middle (function three)\n\t\t\t\t// Even though all functions contain the target text,\n\t\t\t\t// it should match the one closest to line 9 first\n\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent, 9, 9)\n\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\tif (result.success) {\n\t\t\t\t\tassert.strictEqual(result.content, `function one() {\n    return \"target\";\n\nfunction two() {\n    return \"target\";\n\nfunction three() {\n    return \"updated\";\n\nfunction four() {\n    return \"target\";\n\nfunction five() {\n    return \"target\";\n}`)\n\n\t\tsuite(\"line number stripping\", () => {\n\t\t\tsuite(\"line number stripping\", () => {\n\t\t\t\tlet strategy: MultiSearchReplaceDiffStrategy\n\n\t\t\t\tsetup(() => {\n\t\t\t\t\tstrategy = new MultiSearchReplaceDiffStrategy()\n\n\t\t\t\ttest(\"should strip line numbers from both search and replace sections\", async () => {\n\n\t\t\t\t\tconst originalContent = \"function test() {\\n    return true;\\n}\\n\"\n\t\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\n1 | function test() {\n2 |     return true;\n3 | }\n=======\n1 | function test() {\n2 |     return false;\n3 | }\n>>>>>>> REPLACE`\n\n\t\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tassert.strictEqual(result.content, \"function test() {\\n    return false;\\n}\\n\")\n\n\t\t\t\ttest(\"should strip line numbers with leading spaces\", async () => {\n\n\t\t\t\t\tconst originalContent = \"function test() {\\n    return true;\\n}\\n\"\n\t\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\n 1 | function test() {\n 2 |     return true;\n 3 | }\n=======\n 1 | function test() {\n 2 |     return false;\n 3 | }\n>>>>>>> REPLACE`\n\n\t\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tassert.strictEqual(result.content, \"function test() {\\n    return false;\\n}\\n\")\n\n\t\t\t\ttest(\"should not strip when not all lines have numbers in either section\", async () => {\n\n\t\t\t\t\tconst originalContent = \"function test() {\\n    return true;\\n}\\n\"\n\t\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\n1 | function test() {\n2 |     return true;\n3 | }\n=======\n1 | function test() {\n    return false;\n3 | }\n>>>>>>> REPLACE`\n\n\t\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\t\tassert.strictEqual(result.success, false)\n\n\t\t\t\ttest(\"should preserve content that naturally starts with pipe\", async () => {\n\n\t\t\t\t\tconst originalContent = \"|header|another|\\n|---|---|\\n|data|more|\\n\"\n\t\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\n1 | |header|another|\n2 | |---|---|\n3 | |data|more|\n=======\n1 | |header|another|\n2 | |---|---|\n3 | |data|updated|\n>>>>>>> REPLACE`\n\n\t\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tassert.strictEqual(result.content, \"|header|another|\\n|---|---|\\n|data|updated|\\n\")\n\n\t\t\t\ttest(\"should preserve indentation when stripping line numbers\", async () => {\n\n\t\t\t\t\tconst originalContent = \"    function test() {\\n        return true;\\n    }\\n\"\n\t\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\n1 |     function test() {\n2 |         return true;\n3 |     }\n=======\n1 |     function test() {\n2 |         return false;\n3 |     }\n>>>>>>> REPLACE`\n\n\t\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tassert.strictEqual(result.content, \"    function test() {\\n        return false;\\n    }\\n\")\n\n\t\t\t\ttest(\"should handle different line numbers between sections\", async () => {\n\n\t\t\t\t\tconst originalContent = \"function test() {\\n    return true;\\n}\\n\"\n\t\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\n10 | function test() {\n11 |     return true;\n12 | }\n=======\n20 | function test() {\n21 |     return false;\n22 | }\n>>>>>>> REPLACE`\n\n\t\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tassert.strictEqual(result.content, \"function test() {\\n    return false;\\n}\\n\")\n\n\t\t\t\ttest(\"detects search marker when expecting replace\", () => {\n\n\t\t\t\t\tconst diff = \"<<<<<<< SEARCH\\n\" + \"content\\n\" + \"=======\\n\" + \"new content\\n\" + \"<<<<<<< SEARCH\"\n\t\t\t\t\tconst result = strategy[\"validateMarkerSequencing\"](diff)\n\t\t\t\t\tassert.strictEqual(result.success, false)\n\t\t\t\t\tassert.ok(result.error.includes(\"'<<<<<<< SEARCH' found in your diff content\"))\n\n\t\t\t\ttest(\"allows escaped search marker in content\", () => {\n\n\t\t\t\t\tconst diff =\n\t\t\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"before\\n\" +\n\t\t\t\t\t\t\"\\\\<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"after\\n\" +\n\t\t\t\t\t\t\"=======\\n\" +\n\t\t\t\t\t\t\"new content\\n\" +\n\t\t\t\t\t\t\">>>>>>> REPLACE\"\n\t\t\t\t\tconst result = strategy[\"validateMarkerSequencing\"](diff)\n\t\t\t\t\tassert.strictEqual(result.success, true)\n\n\t\t\t\ttest(\"allows escaped separator in content\", () => {\n\n\t\t\t\t\tconst diff =\n\t\t\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"before\\n\" +\n\t\t\t\t\t\t\"\\\\=======\\n\" +\n\t\t\t\t\t\t\"after\\n\" +\n\t\t\t\t\t\t\"=======\\n\" +\n\t\t\t\t\t\t\"new content\\n\" +\n\t\t\t\t\t\t\">>>>>>> REPLACE\"\n\t\t\t\t\tconst result = strategy[\"validateMarkerSequencing\"](diff)\n\t\t\t\t\tassert.strictEqual(result.success, true)\n\n\t\t\t\ttest(\"processes escaped search marker in content\", async () => {\n\n\t\t\t\t\tconst originalContent = \"before\\n<<<<<<< SEARCH\\nafter\\n\"\n\t\t\t\t\tconst diffContent =\n\t\t\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"before\\n\" +\n\t\t\t\t\t\t\"\\\\<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"after\\n\" +\n\t\t\t\t\t\t\"=======\\n\" +\n\t\t\t\t\t\t\"unchanged\\n\" +\n\t\t\t\t\t\t\">>>>>>> REPLACE\"\n\t\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tassert.strictEqual(result.content, \"unchanged\\n\")\n\n\t\t\t\ttest(\"processes escaped separator in content\", async () => {\n\n\t\t\t\t\tconst originalContent = \"before\\n=======\\nafter\\n\"\n\t\t\t\t\tconst diffContent =\n\t\t\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"before\\n\" +\n\t\t\t\t\t\t\"\\\\=======\\n\" +\n\t\t\t\t\t\t\"after\\n\" +\n\t\t\t\t\t\t\"=======\\n\" +\n\t\t\t\t\t\t\"unchanged\\n\" +\n\t\t\t\t\t\t\">>>>>>> REPLACE\"\n\t\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tassert.strictEqual(result.content, \"unchanged\\n\")\n\n\t\t\t\ttest(\"processes escaped search marker in content\", async () => {\n\n\t\t\t\t\tconst originalContent = \"before\\n<<<<<<< SEARCH\\nafter\\n\"\n\t\t\t\t\tconst diffContent =\n\t\t\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"before\\n\" +\n\t\t\t\t\t\t\"\\\\<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"after\\n\" +\n\t\t\t\t\t\t\"=======\\n\" +\n\t\t\t\t\t\t\"unchanged\\n\" +\n\t\t\t\t\t\t\">>>>>>> REPLACE\"\n\t\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tassert.strictEqual(result.content, \"unchanged\\n\")\n\n\t\t\t\ttest(\"processes escaped separator in content\", async () => {\n\n\t\t\t\t\tconst originalContent = \"before\\n=======\\nafter\\n\"\n\t\t\t\t\tconst diffContent =\n\t\t\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"before\\n\" +\n\t\t\t\t\t\t\"\\\\=======\\n\" +\n\t\t\t\t\t\t\"after\\n\" +\n\t\t\t\t\t\t\"=======\\n\" +\n\t\t\t\t\t\t\"unchanged\\n\" +\n\t\t\t\t\t\t\">>>>>>> REPLACE\"\n\t\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tassert.strictEqual(result.content, \"unchanged\\n\")\n\n\t\t\t\ttest(\"processes escaped search marker in content\", async () => {\n\n\t\t\t\t\tconst originalContent = \"before\\n<<<<<<< SEARCH\\nafter\\n\"\n\t\t\t\t\tconst diffContent =\n\t\t\t\t\t\t\"test.ts\\n\" +\n\t\t\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"before\\n\" +\n\t\t\t\t\t\t\"\\\\<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"after\\n\" +\n\t\t\t\t\t\t\"=======\\n\" +\n\t\t\t\t\t\t\"unchanged\\n\" +\n\t\t\t\t\t\t\">>>>>>> REPLACE\"\n\t\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tassert.strictEqual(result.content, \"unchanged\\n\")\n\n\t\t\t\ttest(\"processes escaped search marker in content\", async () => {\n\n\t\t\t\t\tconst originalContent = \"before\\n<<<<<<< SEARCH\\nafter\\n\"\n\t\t\t\t\tconst diffContent =\n\t\t\t\t\t\t\"test.ts\\n\" +\n\t\t\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"before\\n\" +\n\t\t\t\t\t\t\"\\\\<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"after\\n\" +\n\t\t\t\t\t\t\"=======\\n\" +\n\t\t\t\t\t\t\"unchanged\\n\" +\n\t\t\t\t\t\t\">>>>>>> REPLACE\"\n\t\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tassert.strictEqual(result.content, \"unchanged\\n\")\n\n\t\t\t\ttest(\"processes escaped separator in content\", async () => {\n\n\t\t\t\t\tconst originalContent = \"before\\n=======\\nafter\\n\"\n\t\t\t\t\tconst diffContent =\n\t\t\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"before\\n\" +\n\t\t\t\t\t\t\"\\\\=======\\n\" +\n\t\t\t\t\t\t\"after\\n\" +\n\t\t\t\t\t\t\"=======\\n\" +\n\t\t\t\t\t\t\"unchanged\\n\" +\n\t\t\t\t\t\t\">>>>>>> REPLACE\"\n\t\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tassert.strictEqual(result.content, \"unchanged\\n\")\n\n\t\t\t\ttest(\"processes escaped search marker in content\", async () => {\n\n\t\t\t\t\tconst originalContent = \"before\\n<<<<<<< SEARCH\\nafter\\n\"\n\t\t\t\t\tconst diffContent =\n\t\t\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"before\\n\" +\n\t\t\t\t\t\t\"\\\\<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"after\\n\" +\n\t\t\t\t\t\t\"=======\\n\" +\n\t\t\t\t\t\t\"unchanged\\n\" +\n\t\t\t\t\t\t\">>>>>>> REPLACE\"\n\t\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tassert.strictEqual(result.content, \"unchanged\\n\")\n\n\t\t\t\ttest(\"processes escaped search marker in content\", async () => {\n\n\t\t\t\t\tconst originalContent = \"before\\n<<<<<<< SEARCH\\nafter\\n\"\n\t\t\t\t\tconst diffContent =\n\t\t\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"before\\n\" +\n\t\t\t\t\t\t\"\\\\<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"after\\n\" +\n\t\t\t\t\t\t\"=======\\n\" +\n\t\t\t\t\t\t\"unchanged\\n\" +\n\t\t\t\t\t\t\">>>>>>> REPLACE\"\n\t\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tassert.strictEqual(result.content, \"unchanged\\n\")\n\n\t\t\t\ttest(\"processes escaped search marker in content\", async () => {\n\n\t\t\t\t\tconst originalContent = \"before\\n<<<<<<< SEARCH\\nafter\\n\"\n\t\t\t\t\tconst diffContent =\n\t\t\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"before\\n\" +\n\t\t\t\t\t\t\"\\\\<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"after\\n\" +\n\t\t\t\t\t\t\"=======\\n\" +\n\t\t\t\t\t\t\"unchanged\\n\" +\n\t\t\t\t\t\t\">>>>>>> REPLACE\"\n\t\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tassert.strictEqual(result.content, \"unchanged\\n\")\n\n\t\t\t\ttest(\"processes escaped separator in content\", async () => {\n\n\t\t\t\t\tconst originalContent = \"before\\n=======\\nafter\\n\"\n\t\t\t\t\tconst diffContent =\n\t\t\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"before\\n\" +\n\t\t\t\t\t\t\"\\\\=======\\n\" +\n\t\t\t\t\t\t\"after\\n\" +\n\t\t\t\t\t\t\"=======\\n\" +\n\t\t\t\t\t\t\"unchanged\\n\" +\n\t\t\t\t\t\t\">>>>>>> REPLACE\"\n\t\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tassert.strictEqual(result.content, \"unchanged\\n\")\n\n\t\t\t\ttest(\"allows escaped search marker in content\", () => {\n\n\t\t\t\t\tconst diff =\n\t\t\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"before\\n\" +\n\t\t\t\t\t\t\"\\\\<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"after\\n\" +\n\t\t\t\t\t\t\"=======\\n\" +\n\t\t\t\t\t\t\"new content\\n\" +\n\t\t\t\t\t\t\">>>>>>> REPLACE\"\n\t\t\t\t\texpect(strategy[\"validateMarkerSequencing\"](diff).success).toBe(true)\n\n\t\t\t\ttest(\"allows escaped separator in content\", () => {\n\n\t\t\t\t\tconst diff =\n\t\t\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"before\\n\" +\n\t\t\t\t\t\t\"\\\\=======\\n\" +\n\t\t\t\t\t\t\"after\\n\" +\n\t\t\t\t\t\t\"=======\\n\" +\n\t\t\t\t\t\t\"new content\\n\" +\n\t\t\t\t\t\t\">>>>>>> REPLACE\"\n\t\t\t\t\texpect(strategy[\"validateMarkerSequencing\"](diff).success).toBe(true)\n\n\t\t\t\ttest(\"allows escaped search marker in content\", () => {\n\n\t\t\t\t\tconst diff =\n\t\t\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"before\\n\" +\n\t\t\t\t\t\t\"\\\\<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"after\\n\" +\n\t\t\t\t\t\t\"=======\\n\" +\n\t\t\t\t\t\t\"new content\\n\" +\n\t\t\t\t\t\t\">>>>>>> REPLACE\"\n\t\t\t\t\texpect(strategy[\"validateMarkerSequencing\"](diff).success).toBe(true)\n\n\t\t\t\ttest(\"allows escaped search marker in content\", () => {\n\n\t\t\t\t\tconst diff =\n\t\t\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"before\\n\" +\n\t\t\t\t\t\t\"\\\\<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"after\\n\" +\n\t\t\t\t\t\t\"=======\\n\" +\n\t\t\t\t\t\t\"new content\\n\" +\n\t\t\t\t\t\t\">>>>>>> REPLACE\"\n\t\t\t\t\texpect(strategy[\"validateMarkerSequencing\"](diff).success).toBe(true)\n\n\t\t\t\ttest(\"allows escaped separator in content\", () => {\n\n\t\t\t\t\tconst diff =\n\t\t\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"before\\n\" +\n\t\t\t\t\t\t\"\\\\=======\\n\" +\n\t\t\t\t\t\t\"after\\n\" +\n\t\t\t\t\t\t\"=======\\n\" +\n\t\t\t\t\t\t\"new content\\n\" +\n\t\t\t\t\t\t\">>>>>>> REPLACE\"\n\t\t\t\t\texpect(strategy[\"validateMarkerSequencing\"](diff).success).toBe(true)\n\n\t\t\t\ttest(\"allows escaped replace marker in content\", () => {\n\n\t\t\t\t\tconst diff =\n\t\t\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"before\\n\" +\n\t\t\t\t\t\t\"\\\\>>>>>>> REPLACE\\n\" +\n\t\t\t\t\t\t\"after\\n\" +\n\t\t\t\t\t\t\"=======\\n\" +\n\t\t\t\t\t\t\"new content\\n\" +\n\t\t\t\t\t\t\">>>>>>> REPLACE\"\n\t\t\t\t\texpect(strategy[\"validateMarkerSequencing\"](diff).success).toBe(true)\n\n\t\t\t\ttest(\"allows escaped separator in content\", () => {\n\n\t\t\t\t\tconst diff =\n\t\t\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"before\\n\" +\n\t\t\t\t\t\t\"\\\\=======\\n\" +\n\t\t\t\t\t\t\"after\\n\" +\n\t\t\t\t\t\t\"=======\\n\" +\n\t\t\t\t\t\t\"new content\\n\" +\n\t\t\t\t\t\t\">>>>>>> REPLACE\"\n\t\t\t\t\texpect(strategy[\"validateMarkerSequencing\"](diff).success).toBe(true)\n\n\t\t\t\ttest(\"allows escaped replace marker in content\", () => {\n\n\t\t\t\t\tconst diff =\n\t\t\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"before\\n\" +\n\t\t\t\t\t\t\"\\\\>>>>>>> REPLACE\\n\" +\n\t\t\t\t\t\t\"after\\n\" +\n\t\t\t\t\t\t\"=======\\n\" +\n\t\t\t\t\t\t\"new content\\n\" +\n\t\t\t\t\t\t\">>>>>>> REPLACE\"\n\t\t\t\t\texpect(strategy[\"validateMarkerSequencing\"](diff).success).toBe(true)\n\n\t\t\t\ttest(\"allows escaped replace marker in content\", () => {\n\n\t\t\t\t\tconst diff =\n\t\t\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"before\\n\" +\n\t\t\t\t\t\t\"\\\\>>>>>>> REPLACE\\n\" +\n\t\t\t\t\t\t\"after\\n\" +\n\t\t\t\t\t\t\"=======\\n\" +\n\t\t\t\t\t\t\"new content\\n\" +\n\t\t\t\t\t\t\">>>>>>> REPLACE\"\n\t\t\t\t\texpect(strategy[\"validateMarkerSequencing\"](diff).success).toBe(true)\n\n\t\t\t\ttest(\"processes escaped search marker in content\", async () => {\n\n\t\t\t\t\tconst originalContent = \"before\\n<<<<<<< SEARCH\\nafter\\n\"\n\t\t\t\t\tconst diffContent =\n\t\t\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"before\\n\" +\n\t\t\t\t\t\t\"\\\\<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"after\\n\" +\n\t\t\t\t\t\t\"=======\\n\" +\n\t\t\t\t\t\t\"replaced content\\n\" +\n\t\t\t\t\t\t\">>>>>>> REPLACE\"\n\t\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tassert.strictEqual(result.content, \"replaced content\\n\")\n\n\t\t\t\ttest(\"processes escaped replace marker in content\", async () => {\n\n\t\t\t\t\tconst originalContent = \"before\\n>>>>>>> REPLACE\\nafter\\n\"\n\t\t\t\t\tconst diffContent =\n\t\t\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"before\\n\" +\n\t\t\t\t\t\t\"\\\\>>>>>>> REPLACE\\n\" +\n\t\t\t\t\t\t\"after\\n\" +\n\t\t\t\t\t\t\"=======\\n\" +\n\t\t\t\t\t\t\"unchanged\\n\" +\n\t\t\t\t\t\t\">>>>>>> REPLACE\"\n\t\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tassert.strictEqual(result.content, \"unchanged\\n\")\n\n\t\t\t\ttest(\"processes multiple escaped markers in content\", async () => {\n\n\t\t\t\t\tconst originalContent = \"<<<<<<< SEARCH\\n=======\\n>>>>>>> REPLACE\\n\"\n\t\t\t\t\tconst diffContent =\n\t\t\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"\\\\<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"\\\\=======\\n\" +\n\t\t\t\t\t\t\"\\\\>>>>>>> REPLACE\\n\" +\n\t\t\t\t\t\t\"=======\\n\" +\n\t\t\t\t\t\t\"unchanged\\n\" +\n\t\t\t\t\t\t\">>>>>>> REPLACE\"\n\t\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tassert.strictEqual(result.content, \"unchanged\\n\")\n\n\t\t\t\ttest(\"processes escaped separator in content\", async () => {\n\n\t\t\t\t\tconst originalContent = \"before\\n=======\\nafter\\n\"\n\t\t\t\t\tconst diffContent =\n\t\t\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"before\\n\" +\n\t\t\t\t\t\t\"\\\\=======\\n\" +\n\t\t\t\t\t\t\"after\\n\" +\n\t\t\t\t\t\t\"=======\\n\" +\n\t\t\t\t\t\t\"unchanged\\n\" +\n\t\t\t\t\t\t\">>>>>>> REPLACE\"\n\t\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tassert.strictEqual(result.content, \"unchanged\\n\")\n\n\t\t\t\ttest(\"processes escaped search marker in content\", async () => {\n\n\t\t\t\t\tconst originalContent = \"before\\n<<<<<<< SEARCH\\nafter\\n\"\n\t\t\t\t\tconst diffContent =\n\t\t\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"before\\n\" +\n\t\t\t\t\t\t\"\\\\<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"after\\n\" +\n\t\t\t\t\t\t\"=======\\n\" +\n\t\t\t\t\t\t\"unchanged\\n\" +\n\t\t\t\t\t\t\">>>>>>> REPLACE\"\n\t\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tassert.strictEqual(result.content, \"unchanged\\n\")\n\n\t\t\t\ttest(\"processes escaped replace marker in content\", async () => {\n\n\t\t\t\t\tconst originalContent = \"before\\n>>>>>>> REPLACE\\nafter\\n\"\n\t\t\t\t\tconst diffContent =\n\t\t\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"before\\n\" +\n\t\t\t\t\t\t\"\\\\>>>>>>> REPLACE\\n\" +\n\t\t\t\t\t\t\"after\\n\" +\n\t\t\t\t\t\t\"=======\\n\" +\n\t\t\t\t\t\t\"unchanged\\n\" +\n\t\t\t\t\t\t\">>>>>>> REPLACE\"\n\t\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tassert.strictEqual(result.content, \"unchanged\\n\")\n\n\t\t\t\ttest(\"processes escaped separator in content\", async () => {\n\n\t\t\t\t\tconst originalContent = \"before\\n=======\\nafter\\n\"\n\t\t\t\t\tconst diffContent =\n\t\t\t\t\t\t\"test.ts\\n\" +\n\t\t\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"before\\n\" +\n\t\t\t\t\t\t\"\\\\=======\\n\" +\n\t\t\t\t\t\t\"after\\n\" +\n\t\t\t\t\t\t\"=======\\n\" +\n\t\t\t\t\t\t\"unchanged\\n\" +\n\t\t\t\t\t\t\">>>>>>> REPLACE\"\n\t\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tassert.strictEqual(result.content, \"unchanged\\n\")\n\n\t\t\t\ttest(\"processes escaped replace marker in content\", async () => {\n\n\t\t\t\t\tconst originalContent = \"before\\n>>>>>>> REPLACE\\nafter\\n\"\n\t\t\t\t\tconst diffContent =\n\t\t\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"before\\n\" +\n\t\t\t\t\t\t\"\\\\>>>>>>> REPLACE\\n\" +\n\t\t\t\t\t\t\"after\\n\" +\n\t\t\t\t\t\t\"=======\\n\" +\n\t\t\t\t\t\t\"unchanged\\n\" +\n\t\t\t\t\t\t\">>>>>>> REPLACE\"\n\t\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tassert.strictEqual(result.content, \"unchanged\\n\")\n\n\t\t\t\ttest(\"processes multiple escaped markers in content\", async () => {\n\n\t\t\t\t\tconst originalContent = \"<<<<<<< SEARCH\\n=======\\n>>>>>>> REPLACE\\n\"\n\t\t\t\t\tconst diffContent =\n\t\t\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"\\\\<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"\\\\=======\\n\" +\n\t\t\t\t\t\t\"\\\\>>>>>>> REPLACE\\n\" +\n\t\t\t\t\t\t\"=======\\n\" +\n\t\t\t\t\t\t\"unchanged\\n\" +\n\t\t\t\t\t\t\">>>>>>> REPLACE\"\n\t\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tassert.strictEqual(result.content, \"unchanged\\n\")\n\n\t\t\t\ttest(\"processes escaped replace marker in content\", async () => {\n\n\t\t\t\t\tconst originalContent = \"before\\n>>>>>>> REPLACE\\nafter\\n\"\n\t\t\t\t\tconst diffContent =\n\t\t\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"before\\n\" +\n\t\t\t\t\t\t\"\\\\>>>>>>> REPLACE\\n\" +\n\t\t\t\t\t\t\"after\\n\" +\n\t\t\t\t\t\t\"=======\\n\" +\n\t\t\t\t\t\t\"unchanged\\n\" +\n\t\t\t\t\t\t\">>>>>>> REPLACE\"\n\t\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tassert.strictEqual(result.content, \"unchanged\\n\")\n\n\t\t\t\ttest(\"processes multiple escaped markers in content\", async () => {\n\n\t\t\t\t\tconst originalContent = \"<<<<<<< SEARCH\\n=======\\n>>>>>>> REPLACE\\n\"\n\t\t\t\t\tconst diffContent =\n\t\t\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"\\\\<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"\\\\=======\\n\" +\n\t\t\t\t\t\t\"\\\\>>>>>>> REPLACE\\n\" +\n\t\t\t\t\t\t\"=======\\n\" +\n\t\t\t\t\t\t\"unchanged\\n\" +\n\t\t\t\t\t\t\">>>>>>> REPLACE\"\n\t\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\t\tif (result.success) {\n\t\t\t\t\t\tassert.strictEqual(result.content, \"unchanged\\n\")\n\n\t\t\t\ttest(\"allows escaped replace marker in content\", () => {\n\n\t\t\t\t\tconst diff =\n\t\t\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"before\\n\" +\n\t\t\t\t\t\t\"\\\\>>>>>>> REPLACE\\n\" +\n\t\t\t\t\t\t\"after\\n\" +\n\t\t\t\t\t\t\"=======\\n\" +\n\t\t\t\t\t\t\"new content\\n\" +\n\t\t\t\t\t\t\">>>>>>> REPLACE\"\n\t\t\t\t\tconst result = strategy[\"validateMarkerSequencing\"](diff)\n\t\t\t\t\tassert.strictEqual(result.success, true)\n\n\t\t\t\ttest(\"allows multiple escaped markers in content\", () => {\n\n\t\t\t\t\tconst diff =\n\t\t\t\t\t\t\"<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"\\\\<<<<<<< SEARCH\\n\" +\n\t\t\t\t\t\t\"\\\\=======\\n\" +\n\t\t\t\t\t\t\"\\\\>>>>>>> REPLACE\\n\" +\n\t\t\t\t\t\t\"=======\\n\" +\n\t\t\t\t\t\t\"new content\\n\" +\n\t\t\t\t\t\t\">>>>>>> REPLACE\"\n\t\t\t\t\tconst result = strategy[\"validateMarkerSequencing\"](diff)\n\t\t\t\t\tassert.strictEqual(result.success, true)\n\n\t\t\t\ttest(\"detects separator when expecting replace\", () => {\n\n\t\t\t\t\tconst diff = \"<<<<<<< SEARCH\\n\" + \"content\\n\" + \"=======\\n\" + \"new content\\n\" + \"=======\"\n\t\t\t\t\tconst result = strategy[\"validateMarkerSequencing\"](diff)\n\t\t\t\t\tassert.strictEqual(result.success, false)\n\t\t\t\t\tassert.ok(result.error.includes(\"'=======' found in your diff content\"))\n\n\t\t\ttest(\"should not strip content that starts with pipe but no line number\", async () => {\n\n\t\t\t\tconst originalContent = \"| Pipe\\n|---|\\n| Data\\n\"\n\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\n| Pipe\n|---|\n| Data\n=======\n| Pipe\n|---|\n| Updated\n>>>>>>> REPLACE`\n\n\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\tif (result.success) {\n\t\t\t\t\tassert.strictEqual(result.content, \"| Pipe\\n|---|\\n| Updated\\n\")\n\n\t\t\ttest(\"should handle mix of line-numbered and pipe-only content\", async () => {\n\n\t\t\t\tconst originalContent = \"| Pipe\\n|---|\\n| Data\\n\"\n\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\n| Pipe\n|---|\n| Data\n=======\n1 | | Pipe\n2 | |---|\n3 | | NewData\n>>>>>>> REPLACE`\n\n\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\tif (result.success) {\n\t\t\t\t\tassert.strictEqual(result.content, \"1 | | Pipe\\n2 | |---|\\n3 | | NewData\\n\")\n\n\tsuite(\"insertion/deletion\", () => {\n\t\tlet strategy: MultiSearchReplaceDiffStrategy\n\n\t\tsetup(() => {\n\t\t\tstrategy = new MultiSearchReplaceDiffStrategy()\n\n\t\tsuite(\"deletion\", () => {\n\t\t\ttest(\"should delete code when replace block is empty\", async () => {\n\n\t\t\t\tconst originalContent = `function test() {\n    console.log(\"hello\");\n    // Comment to remove\n    console.log(\"world\");\n}`\n\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\n    // Comment to remove\n=======\n>>>>>>> REPLACE`\n\n\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\tif (result.success) {\n\t\t\t\t\tassert.strictEqual(result.content, `function test() {\n    console.log(\"hello\");\n    console.log(\"world\");\n}`)\n\n\t\t\ttest(\"should delete multiple lines when replace block is empty\", async () => {\n\n\t\t\t\tconst originalContent = `class Example {\n    constructor() {\n        // Initialize\n        this.value = 0;\n        // Set defaults\n        this.name = \"\";\n        // End init\n\n}`\n\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\n        // Initialize\n        this.value = 0;\n        // Set defaults\n        this.name = \"\";\n        // End init\n=======\n>>>>>>> REPLACE`\n\n\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\tif (result.success) {\n\t\t\t\t\tassert.strictEqual(result.content, `class Example {\n    constructor() {\n\n}`)\n\n\t\t\ttest(\"should preserve indentation when deleting nested code\", async () => {\n\n\t\t\t\tconst originalContent = `function outer() {\n    if (true) {\n        // Remove this\n        console.log(\"test\");\n        // And this\n\n    return true;\n}`\n\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\n        // Remove this\n        console.log(\"test\");\n        // And this\n=======\n>>>>>>> REPLACE`\n\n\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\tif (result.success) {\n\t\t\t\t\tassert.strictEqual(result.content, `function outer() {\n    if (true) {\n\n    return true;\n}`)\n\n\t\tsuite(\"insertion\", () => {\n\t\t\ttest(\"should insert code at specified line when search block is empty\", async () => {\n\n\t\t\t\tconst originalContent = `function test() {\n    const x = 1;\n    return x;\n}`\n\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\n:start_line:2\n:end_line:2\n-------\n=======\n    console.log(\"Adding log\");\n>>>>>>> REPLACE`\n\n\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent, 2, 2)\n\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\tif (result.success) {\n\t\t\t\t\tassert.strictEqual(result.content, `function test() {\n    console.log(\"Adding log\");\n    const x = 1;\n    return x;\n}`)\n\n\t\t\ttest(\"should preserve indentation when inserting at nested location\", async () => {\n\n\t\t\t\tconst originalContent = `function test() {\n    if (true) {\n        const x = 1;\n\n}`\n\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\n:start_line:3\n:end_line:3\n-------\n=======\n        console.log(\"Before\");\n        console.log(\"After\");\n>>>>>>> REPLACE`\n\n\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent, 3, 3)\n\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\tif (result.success) {\n\t\t\t\t\tassert.strictEqual(result.content, `function test() {\n    if (true) {\n        console.log(\"Before\");\n        console.log(\"After\");\n        const x = 1;\n\n}`)\n\n\t\t\ttest(\"should handle insertion at start of file\", async () => {\n\n\t\t\t\tconst originalContent = `function test() {\n    return true;\n}`\n\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\n:start_line:1\n:end_line:1\n-------\n=======\n// Copyright 2024\n// License: MIT\n\n>>>>>>> REPLACE`\n\n\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent, 1, 1)\n\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\tif (result.success) {\n\t\t\t\t\tassert.strictEqual(result.content, `// Copyright 2024\n// License: MIT\n\nfunction test() {\n    return true;\n}`)\n\n\t\t\ttest(\"should handle insertion at end of file\", async () => {\n\n\t\t\t\tconst originalContent = `function test() {\n    return true;\n}`\n\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\n:start_line:4\n:end_line:4\n-------\n=======\n// End of file\n>>>>>>> REPLACE`\n\n\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent, 4, 4)\n\t\t\t\tassert.strictEqual(result.success, true)\n\t\t\t\tif (result.success) {\n\t\t\t\t\tassert.strictEqual(result.content, `function test() {\n    return true;\n\n// End of file`)\n\n\t\t\ttest(\"should error if no start_line is provided for insertion\", async () => {\n\n\t\t\t\tconst originalContent = `function test() {\n    return true;\n}`\n\t\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\n=======\nconsole.log(\"test\");\n>>>>>>> REPLACE`\n\n\t\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\t\tassert.strictEqual(result.success, false)\n\n\tsuite(\"fuzzy matching\", () => {\n\t\tlet strategy: MultiSearchReplaceDiffStrategy\n\t\tsetup(() => {\n\t\t\tstrategy = new MultiSearchReplaceDiffStrategy(0.9, 5) // 90% similarity threshold, 5 line buffer for tests\n\n\t\ttest(\"should match content with small differences (>90% similar)\", async () => {\n\n\t\t\tconst originalContent =\n\t\t\t\t\"function getData() {\\n    const results = fetchData();\\n    return results.filter(Boolean);\\n}\\n\"\n\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\nfunction getData() {\n    const result = fetchData();\n    return results.filter(Boolean);\n\n=======\nfunction getData() {\n    const data = fetchData();\n    return data.filter(Boolean);\n\n>>>>>>> REPLACE`\n\n\t\t\tstrategy = new MultiSearchReplaceDiffStrategy(0.9, 5) // Use 5 line buffer for tests\n\n\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\tassert.strictEqual(result.success, true)\n\t\t\tif (result.success) {\n\t\t\t\tassert.strictEqual(result.content, \n\t\t\t\t\t\"function getData() {\\n    const data = fetchData();\\n    return data.filter(Boolean);\\n}\\n\",\n\n\t\ttest(\"should not match when content is too different (<90% similar)\", async () => {\n\n\t\t\tconst originalContent = \"function processUsers(data) {\\n    return data.map(user => user.name);\\n}\\n\"\n\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\nfunction handleItems(items) {\n    return items.map(item => item.username);\n\n=======\nfunction processData(data) {\n    return data.map(d => d.value);\n\n>>>>>>> REPLACE`\n\n\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\tassert.strictEqual(result.success, false)\n\n\t\ttest(\"should match content with extra whitespace\", async () => {\n\n\t\t\tconst originalContent = \"function sum(a, b) {\\n    return a + b;\\n}\"\n\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\nfunction   sum(a,   b)    {\n    return    a + b;\n\n=======\nfunction sum(a, b) {\n    return a + b + 1;\n\n>>>>>>> REPLACE`\n\n\t\t\tconst result = await strategy.applyDiff(originalContent, diffContent)\n\t\t\tassert.strictEqual(result.success, true)\n\t\t\tif (result.success) {\n\t\t\t\tassert.strictEqual(result.content, \"function sum(a, b) {\\n    return a + b + 1;\\n}\")\n\n\t\ttest(\"should not exact match empty lines\", async () => {\n\n\t\t\tconst originalContent = \"function sum(a, b) {\\n\\n    return a + b;\\n}\"\n\t\t\tconst diffContent = `test.ts\n<<<<<<< SEARCH\nfunction sum(a, b) {\n=======\nimport "
        ]
      }
    ],
    "e2e/src/suite/core/diff/strategies/new-unified/search-strategies.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { findAnchorMatch, findExactMatch, findSimilarityMatch, findLevenshteinMatch } from \"../search-strategies\"\n\nimport * as"
        ]
      }
    ],
    "e2e/src/suite/core/diff/strategies/new-unified/edit-strategies.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { applyContextMatching, applyDMP, applyGitFallback } from \"../edit-strategies\"\nimport { Hunk } from \"../types\"\n\nimport * as"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 3,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/core/config/importExport.test.ts": [
      {
        "type": "inlineMockAssignments",
        "description": "Floating closing brackets from incomplete mocking",
        "count": 6,
        "examples": [
          "}))",
          "}))"
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          "/* eslint-disable @typescript-eslint/unbound-method */\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n\nimport "
        ]
      }
    ],
    "e2e/src/suite/core/config/ProviderSettingsManager.test.ts": [
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 9,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/core/config/ModeConfig.test.ts": [
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 25,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/core/config/CustomModesSettings.test.ts": [
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 12,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/core/config/CustomModesManager.test.ts": [
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 6,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/core/config/ContextProxy.test.ts": [
      {
        "type": "inlineMockAssignments",
        "description": "Floating closing brackets from incomplete mocking",
        "count": 1,
        "examples": [
          "}))"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 19,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          "/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/no-unsafe-call */\n/* eslint-disable @typescript-eslint/no-unsafe-argument */\n/* eslint-disable @typescript-eslint/await-thenable */\n/* eslint-disable @typescript-eslint/require-await */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport "
        ]
      }
    ],
    "e2e/src/suite/api/provider-enablement-validation.test.ts": [
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          "/**\n * Test to validate that all providers are properly enabled and functional\n * This test specifically addresses issue #107 - Provider Handler Re-enablement\n */\nimport "
        ]
      }
    ],
    "e2e/src/suite/api/ollama-integration.test.ts": [
      {
        "type": "inlineMockAssignments",
        "description": "Floating closing brackets from incomplete mocking",
        "count": 2,
        "examples": [
          "\t\t}))",
          "\t\t}))"
        ]
      }
    ],
    "e2e/src/suite/api/transform/vscode-lm-format.test.ts": [
      {
        "type": "malformedTodoComment",
        "description": "Malformed TODO comment for proxyquire",
        "count": 1,
        "examples": [
          "// TODO: Use proxyquire for module mocking - \"vscode\", () => {"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 2,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/api/transform/vertex-gemini-format.test.ts": [
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 2,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/api/transform/stream.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { ApiStreamChunk } from \"../stream\"\nimport * as"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 1,
        "examples": [
          "expect("
        ]
      }
    ],
    "e2e/src/suite/api/transform/simple-format.test.ts": [
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 9,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          "\tNeutralConversationHistory,\n\tNeutralTextContentBlock,\n\tNeutralImageContentBlock,\n\tNeutralToolUseContentBlock,\n\tNeutralToolResultContentBlock,\n} from \"../../../shared/neutral-history\"\nimport "
        ]
      }
    ],
    "e2e/src/suite/api/transform/r1-format.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { convertToR1Format } from \"../r1-format\"\nimport type { NeutralConversationHistory } from \"../../../shared/neutral-history\"\nimport OpenAI from \"openai\"\nimport * as"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 7,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/api/transform/openrouter.test.ts": [
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 5,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          "\tconvertToOpenRouterFormat, \n\tapplyAnthropicCacheControl, \n\tvalidateOpenRouterParams,\n\tcreateOpenRouterRequest,\n\ttype OpenRouterChatCompletionParams,\n\ttype OpenRouterTransformOptions\n} from \"../openrouter\"\nimport "
        ]
      }
    ],
    "e2e/src/suite/api/transform/neutral-openai-format.test.ts": [
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 1,
        "examples": [
          "expect("
        ]
      }
    ],
    "e2e/src/suite/api/transform/neutral-ollama-format.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import {\nimport * as"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 18,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 2,
        "examples": [
          "\tconvertToOllamaHistory,\n\tconvertToOllamaContentBlocks,\n\tconvertToNeutralHistoryFromOllama,\n} from \"../neutral-ollama-format\"\nimport ",
          "\tNeutralConversationHistory,\n\tNeutralMessageContent,\n\tNeutralTextContentBlock,\n} from \"../../../shared/neutral-history\"\nimport "
        ]
      }
    ],
    "e2e/src/suite/api/transform/mistral-format.test.ts": [
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 3,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/api/providers/vscode-lm.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { VsCodeLmHandler } from \"../vscode-lm\"\nimport { ApiHandlerOptions } from \"../../../shared/api\"\nimport { NeutralConversationHistory } from \"../../../shared/neutral-history\"\nimport * as"
        ]
      },
      {
        "type": "malformedTodoComment",
        "description": "Malformed TODO comment for proxyquire",
        "count": 1,
        "examples": [
          "// TODO: Use proxyquire for module mocking - \"vscode\", () => {"
        ]
      },
      {
        "type": "inlineMockAssignments",
        "description": "Floating closing brackets from incomplete mocking",
        "count": 1,
        "examples": [
          "\t\t\t}))"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 3,
        "examples": [
          "expect(",
          "expect("
        ]
      }
    ],
    "e2e/src/suite/api/providers/vertex.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { VertexHandler } from \"../vertex\"\nimport { ApiHandlerOptions } from \"../../../shared/api\"\nimport { NeutralConversationHistory, NeutralMessageContent } from \"../../../shared/neutral-history\"\nimport * as"
        ]
      },
      {
        "type": "malformedTodoComment",
        "description": "Malformed TODO comment for proxyquire",
        "count": 1,
        "examples": [
          "// TODO: Use proxyquire for module mocking - \"@google-cloud/vertexai\", () => {"
        ]
      },
      {
        "type": "inlineMockAssignments",
        "description": "Floating closing brackets from incomplete mocking",
        "count": 1,
        "examples": [
          "}))"
        ]
      }
    ],
    "e2e/src/suite/api/providers/vertex.edge-cases.test.ts": [
      {
        "type": "malformedCommentImport",
        "description": "Import statement followed by comment block",
        "count": 1,
        "examples": [
          "import * as sinon from 'sinon'/**\n * Vertex provider edge case tests as recommended by architect\n * Tests Claude/Gemini paths, thinking variants, completePrompt helpers\n */"
        ]
      },
      {
        "type": "inlineMockAssignments",
        "description": "Floating closing brackets from incomplete mocking",
        "count": 2,
        "examples": [
          "\t\t\t}))",
          "\t\t\t}))"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 6,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          " * Vertex provider edge case tests as recommended by architect\n * Tests Claude/Gemini paths, thinking variants, completePrompt helpers\n */\n\nimport "
        ]
      }
    ],
    "e2e/src/suite/api/providers/unbound.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { UnboundHandler } from \"../unbound\"\nimport { ApiHandlerOptions } from \"../../../shared/api\"\nimport type { NeutralConversationHistory } from \"../../../shared/neutral-history\"\nimport type OpenAI from \"openai\" // Added for types\nimport { EXTENSION_NAME } from \"../../../shared/config/thea-config\"\nimport type { ApiStreamChunk } from \"../../transform/stream\" // Added for chunk typing\nimport * as"
        ]
      },
      {
        "type": "malformedTodoComment",
        "description": "Malformed TODO comment for proxyquire",
        "count": 1,
        "examples": [
          "// TODO: Use proxyquire for module mocking - \"openai\", () => {"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 9,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "mockImplementationOnce",
        "description": "Jest mock methods needing conversion to sinon",
        "count": 1,
        "examples": [
          ".mockImplementationOnce("
        ]
      }
    ],
    "e2e/src/suite/api/providers/requesty.test.ts": [
      {
        "type": "inlineMockAssignments",
        "description": "Floating closing brackets from incomplete mocking",
        "count": 3,
        "examples": [
          "\t\t\t}))",
          "\t\t\t\t}))"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 1,
        "examples": [
          "expect("
        ]
      }
    ],
    "e2e/src/suite/api/providers/openrouter.test.ts": [
      {
        "type": "inlineMockAssignments",
        "description": "Floating closing brackets from incomplete mocking",
        "count": 2,
        "examples": [
          "\t\t}))",
          "\t\t}))"
        ]
      }
    ],
    "e2e/src/suite/api/providers/openai.test.ts": [
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 8,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "standaloneSetup",
        "description": "setup() outside of suite block",
        "count": 1,
        "examples": [
          "setup("
        ]
      }
    ],
    "e2e/src/suite/api/providers/openai.edge-cases.test.ts": [
      {
        "type": "malformedCommentImport",
        "description": "Import statement followed by comment block",
        "count": 1,
        "examples": [
          "import * as sinon from 'sinon'/**\n * OpenAI provider edge case tests\n * Tests streaming/non-streaming, XmlMatcher reasoning, tool_calls to MCP conversion\n */"
        ]
      },
      {
        "type": "malformedTodoComment",
        "description": "Malformed TODO comment for proxyquire",
        "count": 1,
        "examples": [
          "// TODO: Use proxyquire for module mocking - \"openai\", () => {"
        ]
      },
      {
        "type": "inlineMockAssignments",
        "description": "Floating closing brackets from incomplete mocking",
        "count": 13,
        "examples": [
          "}))",
          "\t\t}))"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 12,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 2,
        "examples": [
          " * OpenAI provider edge case tests\n * Tests streaming/non-streaming, XmlMatcher reasoning, tool_calls to MCP conversion\n */\n\nimport ",
          "\tNeutralConversationHistory, \n\tNeutralMessageContent,\n\tNeutralMessage,\n\tNeutralContentBlock,\n\tNeutralTextContentBlock \n} from \"../../../shared/neutral-history\"\nimport "
        ]
      }
    ],
    "e2e/src/suite/api/providers/openai-usage-tracking.test.ts": [
      {
        "type": "standaloneSetup",
        "description": "setup() outside of suite block",
        "count": 1,
        "examples": [
          "setup("
        ]
      }
    ],
    "e2e/src/suite/api/providers/openai-native.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { OpenAiNativeHandler } from \"../openai-native\"\nimport { ApiHandlerOptions } from \"../../../shared/api\"\nimport { NeutralMessage } from \"../../../shared/neutral-history\"\nimport {\nimport * as"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 6,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "standaloneSetup",
        "description": "setup() outside of suite block",
        "count": 1,
        "examples": [
          "setup("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          "} from \"../../transform/stream\"\nimport "
        ]
      }
    ],
    "e2e/src/suite/api/providers/model-registry.test.ts": [
      {
        "type": "malformedCommentImport",
        "description": "Import statement followed by comment block",
        "count": 1,
        "examples": [
          "import * as sinon from 'sinon'/**\n * Model Registry Tests\n * Tests for the dynamic model information extraction system\n */"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 2,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 2,
        "examples": [
          " * Model Registry Tests\n * Tests for the dynamic model information extraction system\n */\n\nimport ",
          "\tModelRegistry, \n\tModelProvider, \n\tModelListing,\n\tStaticModelProvider,\n\tmigrateStaticModels\n} from \"../model-registry\"\nimport "
        ]
      }
    ],
    "e2e/src/suite/api/providers/bedrock.edge-cases.test.ts": [
      {
        "type": "malformedCommentImport",
        "description": "Import statement followed by comment block",
        "count": 1,
        "examples": [
          "import * as sinon from 'sinon'/**\n * Bedrock provider edge case tests as recommended by architect\n * Tests ARN validation, cross-region inference, credentials modes, error/usage handling\n */"
        ]
      },
      {
        "type": "inlineMockAssignments",
        "description": "Floating closing brackets from incomplete mocking",
        "count": 1,
        "examples": [
          "\t\t}))"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 7,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          " * Bedrock provider edge case tests as recommended by architect\n * Tests ARN validation, cross-region inference, credentials modes, error/usage handling\n */\n\nimport "
        ]
      }
    ],
    "e2e/src/suite/api/providers/base-provider.schema-only.test.ts": [
      {
        "type": "malformedCommentImport",
        "description": "Import statement followed by comment block",
        "count": 1,
        "examples": [
          "import * as sinon from 'sinon'/**\n * BaseProvider schema-only registration tests\n * Verifies that BaseProvider only registers tool schemas and delegates execution to MCP\n */"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 14,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          " * BaseProvider schema-only registration tests\n * Verifies that BaseProvider only registers tool schemas and delegates execution to MCP\n */\n\nimport "
        ]
      }
    ],
    "e2e/src/suite/api/providers/anthropic.edge-cases.test.ts": [
      {
        "type": "inlineMockAssignments",
        "description": "Floating closing brackets from incomplete mocking",
        "count": 3,
        "examples": [
          "\t\t\t}))",
          "\t\t\t}))"
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          "/**\n * Anthropic provider edge case tests\n * Tests thinking budget clamping, tool_use to tool_result conversion, countTokens fallback\n */\n\nimport "
        ]
      }
    ],
    "e2e/src/suite/api/providers/all-dynamic-providers.runtime.test.ts": [
      {
        "type": "malformedCommentImport",
        "description": "Import statement followed by comment block",
        "count": 1,
        "examples": [
          "import * as sinon from 'sinon'/**\n * Comprehensive runtime test for all dynamic model providers\n * Tests that all 14 providers can successfully fetch models from their respective mock APIs\n */"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 15,
        "examples": [
          "expect(",
          "expect("
        ]
      },
      {
        "type": "importsAfterCode",
        "description": "Import statements after code has started",
        "count": 1,
        "examples": [
          " * Comprehensive runtime test for all dynamic model providers\n * Tests that all 14 providers can successfully fetch models from their respective mock APIs\n */\n\nimport "
        ]
      }
    ],
    "e2e/src/suite/api/providers/shared/tool-use.test.ts": [
      {
        "type": "malformedImportAfterBrace",
        "description": "Import statement inside another import",
        "count": 1,
        "examples": [
          "import { ToolCallAggregator, extractToolCallsFromDelta } from \"../tool-use\"\nimport type OpenAI from \"openai\"\n\nimport * as"
        ]
      },
      {
        "type": "expectSyntax",
        "description": "Jest expect calls that need conversion to assert",
        "count": 1,
        "examples": [
          "expect("
        ]
      }
    ]
  },
  "fixProposals": [
    "e2e/src/suite/utils/port-utils.retry-timeout.test.ts",
    "e2e/src/suite/utils/model-pattern-detection.test.ts",
    "e2e/src/suite/utils/model-capabilities.test.ts",
    "e2e/src/suite/utils/json-xml-bridge.test.ts",
    "e2e/src/suite/utils/json-xml-bridge.edge-cases.test.ts",
    "e2e/src/suite/utils/logging/CompactTransport.test.ts",
    "e2e/src/suite/test/dynamic-providers-mock.test.ts",
    "e2e/src/suite/test/generic-provider-mock/all-providers-runtime.test.ts",
    "e2e/src/suite/shared/support-prompts.test.ts",
    "e2e/src/suite/shared/modes.test.ts",
    "e2e/src/suite/shared/language.test.ts",
    "e2e/src/suite/shared/formatPath.test.ts",
    "e2e/src/suite/shared/experiments.test.ts",
    "e2e/src/suite/shared/doesFileMatchRegex.test.ts",
    "e2e/src/suite/shared/context-mentions.test.ts",
    "e2e/src/suite/shared/checkExistApiConfig.test.ts",
    "e2e/src/suite/services/tree-sitter/index.test.ts",
    "e2e/src/suite/services/mcp/ollama-mcp-integration.test.ts",
    "e2e/src/suite/services/mcp/UnifiedMcpToolSystem.test.ts",
    "e2e/src/suite/services/mcp/SseTransport.test.ts",
    "e2e/src/suite/services/mcp/McpToolRegistry.test.ts",
    "e2e/src/suite/services/mcp/McpIntegration.test.ts",
    "e2e/src/suite/services/mcp/McpHub.test.ts",
    "e2e/src/suite/services/mcp/transport/StdioTransport.lifecycle.test.ts",
    "e2e/src/suite/services/mcp/transport/StdioTransport.fallback.test.ts",
    "e2e/src/suite/services/mcp/transport/SseTransport.lifecycle.test.ts",
    "e2e/src/suite/services/mcp/providers/MockMcpProvider.test.ts",
    "e2e/src/suite/services/mcp/providers/EmbeddedMcpProvider.lifecycle.test.ts",
    "e2e/src/suite/services/mcp/integration/ProviderTransportIntegration.test.ts",
    "e2e/src/suite/services/mcp/formats/OpenAIFunctionFormat.test.ts",
    "e2e/src/suite/services/mcp/core/McpToolRouter.test.ts",
    "e2e/src/suite/services/mcp/core/McpToolRouter.round-trip.test.ts",
    "e2e/src/suite/services/mcp/core/McpToolRouter.lifecycle.test.ts",
    "e2e/src/suite/services/mcp/core/McpToolExecutor.test.ts",
    "e2e/src/suite/services/mcp/core/McpConverters.xml-escaping.test.ts",
    "e2e/src/suite/services/mcp/core/McpConverters.test.ts",
    "e2e/src/suite/services/mcp/core/McpConverters.edge-cases.test.ts",
    "e2e/src/suite/services/mcp/__tests__/performance/PerformanceValidation.test.ts",
    "e2e/src/suite/services/mcp/__tests__/formats/OpenAIFunctionFormat.test.ts",
    "e2e/src/suite/services/checkpoints/excludes.test.ts",
    "e2e/src/suite/services/checkpoints/ShadowCheckpointService.test.ts",
    "e2e/src/suite/schemas/index.test.ts",
    "e2e/src/suite/integrations/workspace/WorkspaceTracker.test.ts",
    "e2e/src/suite/integrations/misc/line-counter.test.ts",
    "e2e/src/suite/integrations/misc/extract-text.test.ts",
    "e2e/src/suite/integrations/editor/detect-omission.test.ts",
    "e2e/src/suite/core/read-file-maxReadFileLine.test.ts",
    "e2e/src/suite/core/mode-validator.test.ts",
    "e2e/src/suite/core/EditorUtils.test.ts",
    "e2e/src/suite/core/CodeActionProvider2.test.ts",
    "e2e/src/suite/core/CodeActionProvider.test.ts",
    "e2e/src/suite/core/webview/TheaTaskStack.test.ts",
    "e2e/src/suite/core/webview/TheaMcpManager.test.ts",
    "e2e/src/suite/core/webview/TheaCacheManager.test.ts",
    "e2e/src/suite/core/tools/attemptCompletionTool.flow.test.ts",
    "e2e/src/suite/core/sliding-window/sliding-window.test.ts",
    "e2e/src/suite/core/prompts/system.test.ts",
    "e2e/src/suite/core/prompts/sections.test.ts",
    "e2e/src/suite/core/prompts/responses-theaignore.test.ts",
    "e2e/src/suite/core/prompts/custom-system-prompt.test.ts",
    "e2e/src/suite/core/prompts/sections/custom-instructions.test.ts",
    "e2e/src/suite/core/ignore/TheaIgnoreController.test.ts",
    "e2e/src/suite/core/ignore/TheaIgnoreController.security.test.ts",
    "e2e/src/suite/core/diff/strategies/multi-search-replace.test.ts",
    "e2e/src/suite/core/diff/strategies/new-unified/edit-strategies.test.ts",
    "e2e/src/suite/core/config/ProviderSettingsManager.test.ts",
    "e2e/src/suite/core/config/ModeConfig.test.ts",
    "e2e/src/suite/core/config/CustomModesManager.test.ts",
    "e2e/src/suite/core/config/ContextProxy.test.ts",
    "e2e/src/suite/api/transform/vscode-lm-format.test.ts",
    "e2e/src/suite/api/transform/stream.test.ts",
    "e2e/src/suite/api/transform/simple-format.test.ts",
    "e2e/src/suite/api/transform/r1-format.test.ts",
    "e2e/src/suite/api/transform/openrouter.test.ts",
    "e2e/src/suite/api/transform/neutral-openai-format.test.ts",
    "e2e/src/suite/api/transform/neutral-ollama-format.test.ts",
    "e2e/src/suite/api/transform/mistral-format.test.ts",
    "e2e/src/suite/api/providers/vscode-lm.test.ts",
    "e2e/src/suite/api/providers/vertex.test.ts",
    "e2e/src/suite/api/providers/vertex.edge-cases.test.ts",
    "e2e/src/suite/api/providers/unbound.test.ts",
    "e2e/src/suite/api/providers/openai.test.ts",
    "e2e/src/suite/api/providers/openai.edge-cases.test.ts",
    "e2e/src/suite/api/providers/openai-native.test.ts",
    "e2e/src/suite/api/providers/model-registry.test.ts",
    "e2e/src/suite/api/providers/bedrock.edge-cases.test.ts",
    "e2e/src/suite/api/providers/base-provider.schema-only.test.ts",
    "e2e/src/suite/api/providers/all-dynamic-providers.runtime.test.ts",
    "e2e/src/suite/api/providers/shared/tool-use.test.ts"
  ]
}